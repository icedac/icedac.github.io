// generated by SQL COMPILER
// time : 2018-07-12 09:57:58.966
// do not modify
// contact: icedac@gmail.com
#pragma once
#pragma warning(push)
#pragma warning(disable: 4100) // unreferenced formal parameter

namespace bb_game {

	using corn::FormatString;

	inline const char* name_A() { return "bb_game"; }
	inline const wchar_t* name_W() { return L"bb_game"; };
	inline const TCHAR* name() { return _T("bb_game"); }
	const int64_t version = 0x0000000000000020; // 32
	const int64_t minor_version = 0x01d4197b60674740; // 131758306789640000

	/****************************************************************************
	*
	*	stored procedure: sp_version_check
	*/
	struct sp_version_check
	{
		static const char* name_A() { return "sp_version_check"; }
		static const wchar_t* name_W() { return L"sp_version_check"; };
		static const TCHAR* name() { return _T("sp_version_check"); }

		struct sp_t {

			struct out_t {
				std::int64_t version; // bigint
				std::int64_t minor_version; // bigint

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, version, "version")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, minor_version, "minor_version")
				END_OTLA_BINDING
			} out;


			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.version, "version")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.minor_version, "minor_version")
			END_OTLA_BINDING
		}; // struct sp {

		//
		oTLA::StoredProcedure<sp_t> sp;
		oTLA::Search<sp_t::out_t> out;
	
		template < typename UPDATER >
		void open( UPDATER* u, const TCHAR* db_name = nullptr )
		{
			auto sp_name = FormatString(_T("%s.%s"), db_name ? db_name : bb_game::name(), name() ).AsString();
			sp.Open(u, sp_name.c_str());
			out.Open(u,nullptr);
		}
	};

	template <typename E>
	inline auto Enum_AsInt(E const value)
		-> typename std::underlying_type<E>::type {
		return static_cast<typename std::underlying_type<E>::type>(value);
	}
	
	enum class Error : std::int32_t {
		SUCCESS = 0,
		ERR_GENERAL = 1,
		ERR_NOT_IMPLEMENTED = 2,
		ERR_SESSION_SERVER = 3,
		ERR_HAS_PENDING_REQUEST = 4,
		ERR_ALREADY_LOGGED_IN = 100,
		ERR_WRONG_VERSION = 101,
		ERR_FORCE_DISCONNECT_INACTIVE_ACCOUNT = 102,
		ERR_SESSION_NOT_FOUND = 103,
		ERR_WRONG_PARAMETER_ACCT_NAME = 200,
		ERR_WRONG_PARAMETER_1 = 201,
		ERR_WRONG_PARAMETER_2 = 202,
		ERR_WRONG_PARAMETER_3 = 203,
		ERR_WRONG_PARAMETER_4 = 204,
		ERR_WRONG_PARAMETER_5 = 205,
		ERR_WRONG_PARAMETER_COST = 206,
		ERR_WRONG_PARAMETER = 299,
		ERR_RESOURCE_NOT_FOUND = 300,
		ERR_RESOURCE_NOT_FOUND_SOURCE = 301,
		ERR_RESOURCE_NOT_FOUND_TARGET = 302,
		ERR_ACCESS_DENIED = 400,
		ERR_ACCESS_DENIED_PROTECTED = 401,
		ERR_ACCESS_DENIED_SOURCE = 402,
		ERR_ACCESS_DENIED_TARGET = 403,
		ERR_DB_SERVER = 500,
		ERR_DB_SERVER_SQLEXCEPTION = 501,
		ERR_DB_SERVER_SQLWARNING = 502,
		ERR_INSURFFICIENT_RESOURCE = 1100,
		ERR_INSURFFICIENT_GAME_MONEY = 1101,
		ERR_INSURFFICIENT_GAME_CASH = 1102,
		ERR_INSURFFICIENT_HONOR_POINT = 1103,
		ERR_INSURFFICIENT_AP = 1104,
		ERR_INSURFFICIENT_ITEM_MATERIAL = 1105,
		ERR_INSURFFICIENT_INVENTORY = 1106,
		ERR_OPERATION_NOT_READY = 1200,
		ERR_ACCOUNT_EVENT_RAISED = 1300,
		ERR_ACCOUNT_EVENT_NOT_FOUND = 1301,
	};
	// Error_AsStr
	inline const char* Error_AsStrA(Error r) {
		switch (r) {
		case Error::SUCCESS: return "SUCCESS";
		case Error::ERR_GENERAL: return "ERR_GENERAL";
		case Error::ERR_NOT_IMPLEMENTED: return "ERR_NOT_IMPLEMENTED";
		case Error::ERR_SESSION_SERVER: return "ERR_SESSION_SERVER";
		case Error::ERR_HAS_PENDING_REQUEST: return "ERR_HAS_PENDING_REQUEST";
		case Error::ERR_ALREADY_LOGGED_IN: return "ERR_ALREADY_LOGGED_IN";
		case Error::ERR_WRONG_VERSION: return "ERR_WRONG_VERSION";
		case Error::ERR_FORCE_DISCONNECT_INACTIVE_ACCOUNT: return "ERR_FORCE_DISCONNECT_INACTIVE_ACCOUNT";
		case Error::ERR_SESSION_NOT_FOUND: return "ERR_SESSION_NOT_FOUND";
		case Error::ERR_WRONG_PARAMETER_ACCT_NAME: return "ERR_WRONG_PARAMETER_ACCT_NAME";
		case Error::ERR_WRONG_PARAMETER_1: return "ERR_WRONG_PARAMETER_1";
		case Error::ERR_WRONG_PARAMETER_2: return "ERR_WRONG_PARAMETER_2";
		case Error::ERR_WRONG_PARAMETER_3: return "ERR_WRONG_PARAMETER_3";
		case Error::ERR_WRONG_PARAMETER_4: return "ERR_WRONG_PARAMETER_4";
		case Error::ERR_WRONG_PARAMETER_5: return "ERR_WRONG_PARAMETER_5";
		case Error::ERR_WRONG_PARAMETER_COST: return "ERR_WRONG_PARAMETER_COST";
		case Error::ERR_WRONG_PARAMETER: return "ERR_WRONG_PARAMETER";
		case Error::ERR_RESOURCE_NOT_FOUND: return "ERR_RESOURCE_NOT_FOUND";
		case Error::ERR_RESOURCE_NOT_FOUND_SOURCE: return "ERR_RESOURCE_NOT_FOUND_SOURCE";
		case Error::ERR_RESOURCE_NOT_FOUND_TARGET: return "ERR_RESOURCE_NOT_FOUND_TARGET";
		case Error::ERR_ACCESS_DENIED: return "ERR_ACCESS_DENIED";
		case Error::ERR_ACCESS_DENIED_PROTECTED: return "ERR_ACCESS_DENIED_PROTECTED";
		case Error::ERR_ACCESS_DENIED_SOURCE: return "ERR_ACCESS_DENIED_SOURCE";
		case Error::ERR_ACCESS_DENIED_TARGET: return "ERR_ACCESS_DENIED_TARGET";
		case Error::ERR_DB_SERVER: return "ERR_DB_SERVER";
		case Error::ERR_DB_SERVER_SQLEXCEPTION: return "ERR_DB_SERVER_SQLEXCEPTION";
		case Error::ERR_DB_SERVER_SQLWARNING: return "ERR_DB_SERVER_SQLWARNING";
		case Error::ERR_INSURFFICIENT_RESOURCE: return "ERR_INSURFFICIENT_RESOURCE";
		case Error::ERR_INSURFFICIENT_GAME_MONEY: return "ERR_INSURFFICIENT_GAME_MONEY";
		case Error::ERR_INSURFFICIENT_GAME_CASH: return "ERR_INSURFFICIENT_GAME_CASH";
		case Error::ERR_INSURFFICIENT_HONOR_POINT: return "ERR_INSURFFICIENT_HONOR_POINT";
		case Error::ERR_INSURFFICIENT_AP: return "ERR_INSURFFICIENT_AP";
		case Error::ERR_INSURFFICIENT_ITEM_MATERIAL: return "ERR_INSURFFICIENT_ITEM_MATERIAL";
		case Error::ERR_INSURFFICIENT_INVENTORY: return "ERR_INSURFFICIENT_INVENTORY";
		case Error::ERR_OPERATION_NOT_READY: return "ERR_OPERATION_NOT_READY";
		case Error::ERR_ACCOUNT_EVENT_RAISED: return "ERR_ACCOUNT_EVENT_RAISED";
		case Error::ERR_ACCOUNT_EVENT_NOT_FOUND: return "ERR_ACCOUNT_EVENT_NOT_FOUND";
		}
		return "Error::UNDEFINED";
	}
	inline const wchar_t* Error_AsStrW(Error r) {
		switch (r) {
		case Error::SUCCESS: return L"SUCCESS";
		case Error::ERR_GENERAL: return L"ERR_GENERAL";
		case Error::ERR_NOT_IMPLEMENTED: return L"ERR_NOT_IMPLEMENTED";
		case Error::ERR_SESSION_SERVER: return L"ERR_SESSION_SERVER";
		case Error::ERR_HAS_PENDING_REQUEST: return L"ERR_HAS_PENDING_REQUEST";
		case Error::ERR_ALREADY_LOGGED_IN: return L"ERR_ALREADY_LOGGED_IN";
		case Error::ERR_WRONG_VERSION: return L"ERR_WRONG_VERSION";
		case Error::ERR_FORCE_DISCONNECT_INACTIVE_ACCOUNT: return L"ERR_FORCE_DISCONNECT_INACTIVE_ACCOUNT";
		case Error::ERR_SESSION_NOT_FOUND: return L"ERR_SESSION_NOT_FOUND";
		case Error::ERR_WRONG_PARAMETER_ACCT_NAME: return L"ERR_WRONG_PARAMETER_ACCT_NAME";
		case Error::ERR_WRONG_PARAMETER_1: return L"ERR_WRONG_PARAMETER_1";
		case Error::ERR_WRONG_PARAMETER_2: return L"ERR_WRONG_PARAMETER_2";
		case Error::ERR_WRONG_PARAMETER_3: return L"ERR_WRONG_PARAMETER_3";
		case Error::ERR_WRONG_PARAMETER_4: return L"ERR_WRONG_PARAMETER_4";
		case Error::ERR_WRONG_PARAMETER_5: return L"ERR_WRONG_PARAMETER_5";
		case Error::ERR_WRONG_PARAMETER_COST: return L"ERR_WRONG_PARAMETER_COST";
		case Error::ERR_WRONG_PARAMETER: return L"ERR_WRONG_PARAMETER";
		case Error::ERR_RESOURCE_NOT_FOUND: return L"ERR_RESOURCE_NOT_FOUND";
		case Error::ERR_RESOURCE_NOT_FOUND_SOURCE: return L"ERR_RESOURCE_NOT_FOUND_SOURCE";
		case Error::ERR_RESOURCE_NOT_FOUND_TARGET: return L"ERR_RESOURCE_NOT_FOUND_TARGET";
		case Error::ERR_ACCESS_DENIED: return L"ERR_ACCESS_DENIED";
		case Error::ERR_ACCESS_DENIED_PROTECTED: return L"ERR_ACCESS_DENIED_PROTECTED";
		case Error::ERR_ACCESS_DENIED_SOURCE: return L"ERR_ACCESS_DENIED_SOURCE";
		case Error::ERR_ACCESS_DENIED_TARGET: return L"ERR_ACCESS_DENIED_TARGET";
		case Error::ERR_DB_SERVER: return L"ERR_DB_SERVER";
		case Error::ERR_DB_SERVER_SQLEXCEPTION: return L"ERR_DB_SERVER_SQLEXCEPTION";
		case Error::ERR_DB_SERVER_SQLWARNING: return L"ERR_DB_SERVER_SQLWARNING";
		case Error::ERR_INSURFFICIENT_RESOURCE: return L"ERR_INSURFFICIENT_RESOURCE";
		case Error::ERR_INSURFFICIENT_GAME_MONEY: return L"ERR_INSURFFICIENT_GAME_MONEY";
		case Error::ERR_INSURFFICIENT_GAME_CASH: return L"ERR_INSURFFICIENT_GAME_CASH";
		case Error::ERR_INSURFFICIENT_HONOR_POINT: return L"ERR_INSURFFICIENT_HONOR_POINT";
		case Error::ERR_INSURFFICIENT_AP: return L"ERR_INSURFFICIENT_AP";
		case Error::ERR_INSURFFICIENT_ITEM_MATERIAL: return L"ERR_INSURFFICIENT_ITEM_MATERIAL";
		case Error::ERR_INSURFFICIENT_INVENTORY: return L"ERR_INSURFFICIENT_INVENTORY";
		case Error::ERR_OPERATION_NOT_READY: return L"ERR_OPERATION_NOT_READY";
		case Error::ERR_ACCOUNT_EVENT_RAISED: return L"ERR_ACCOUNT_EVENT_RAISED";
		case Error::ERR_ACCOUNT_EVENT_NOT_FOUND: return L"ERR_ACCOUNT_EVENT_NOT_FOUND";
		}
		return L"Error::UNDEFINED";
	}
	template < typename CharType >
	inline const CharType* T_Error_AsStr(Error r);
	template <>
	inline const char* T_Error_AsStr(Error r) { return Error_AsStrA(r); }
	template <>
	inline const wchar_t* T_Error_AsStr(Error r) { return Error_AsStrW(r); }
	inline const TCHAR* Error_AsStr(Error r) { return T_Error_AsStr<TCHAR>(r); }
	
	// Error_AsDesc
	inline const char* Error_AsDescA(Error r) {
		switch (r) {
		case Error::SUCCESS: return "success";
		case Error::ERR_GENERAL: return "error";
		case Error::ERR_NOT_IMPLEMENTED: return "not implemented";
		case Error::ERR_SESSION_SERVER: return "session error";
		case Error::ERR_HAS_PENDING_REQUEST: return "client should wait until last response receive";
		case Error::ERR_ALREADY_LOGGED_IN: return "already logged in";
		case Error::ERR_WRONG_VERSION: return "wrong version";
		case Error::ERR_FORCE_DISCONNECT_INACTIVE_ACCOUNT: return "disconnect inactive account, try to logged in again";
		case Error::ERR_SESSION_NOT_FOUND: return "ERR_SESSION_NOT_FOUND";
		case Error::ERR_WRONG_PARAMETER_ACCT_NAME: return "wrong parameter";
		case Error::ERR_WRONG_PARAMETER_1: return "wrong parameter: 1st";
		case Error::ERR_WRONG_PARAMETER_2: return "wrong parameter: 2nd";
		case Error::ERR_WRONG_PARAMETER_3: return "wrong parameter: 3rd";
		case Error::ERR_WRONG_PARAMETER_4: return "wrong parameter: 4th";
		case Error::ERR_WRONG_PARAMETER_5: return "wrong parameter: 5th";
		case Error::ERR_WRONG_PARAMETER_COST: return "ERR_WRONG_PARAMETER_COST";
		case Error::ERR_WRONG_PARAMETER: return "ERR_WRONG_PARAMETER";
		case Error::ERR_RESOURCE_NOT_FOUND: return "resource not found";
		case Error::ERR_RESOURCE_NOT_FOUND_SOURCE: return "resource not found(source)";
		case Error::ERR_RESOURCE_NOT_FOUND_TARGET: return "resource not found(target)";
		case Error::ERR_ACCESS_DENIED: return "acess denied";
		case Error::ERR_ACCESS_DENIED_PROTECTED: return "acess denied: protected";
		case Error::ERR_ACCESS_DENIED_SOURCE: return "ERR_ACCESS_DENIED_SOURCE";
		case Error::ERR_ACCESS_DENIED_TARGET: return "ERR_ACCESS_DENIED_TARGET";
		case Error::ERR_DB_SERVER: return "DB ERROR";
		case Error::ERR_DB_SERVER_SQLEXCEPTION: return "db error";
		case Error::ERR_DB_SERVER_SQLWARNING: return "db error";
		case Error::ERR_INSURFFICIENT_RESOURCE: return "ERR_INSURFFICIENT_RESOURCE";
		case Error::ERR_INSURFFICIENT_GAME_MONEY: return "ERR_INSURFFICIENT_GAME_MONEY";
		case Error::ERR_INSURFFICIENT_GAME_CASH: return "ERR_INSURFFICIENT_GAME_CASH";
		case Error::ERR_INSURFFICIENT_HONOR_POINT: return "ERR_INSURFFICIENT_HONOR_POINT";
		case Error::ERR_INSURFFICIENT_AP: return "ERR_INSURFFICIENT_AP";
		case Error::ERR_INSURFFICIENT_ITEM_MATERIAL: return "ERR_INSURFFICIENT_ITEM_MATERIAL";
		case Error::ERR_INSURFFICIENT_INVENTORY: return "ERR_INSURFFICIENT_INVENTORY";
		case Error::ERR_OPERATION_NOT_READY: return "need to wait cool time";
		case Error::ERR_ACCOUNT_EVENT_RAISED: return "AccountEvent should be resolved by ResolveAccountEventReq";
		case Error::ERR_ACCOUNT_EVENT_NOT_FOUND: return "ERR_ACCOUNT_EVENT_NOT_FOUND";
		}
		return "Error::UNDEFINED";
	}
	inline const wchar_t* Error_AsDescW(Error r) {
		switch (r) {
		case Error::SUCCESS: return L"success";
		case Error::ERR_GENERAL: return L"error";
		case Error::ERR_NOT_IMPLEMENTED: return L"not implemented";
		case Error::ERR_SESSION_SERVER: return L"session error";
		case Error::ERR_HAS_PENDING_REQUEST: return L"client should wait until last response receive";
		case Error::ERR_ALREADY_LOGGED_IN: return L"already logged in";
		case Error::ERR_WRONG_VERSION: return L"wrong version";
		case Error::ERR_FORCE_DISCONNECT_INACTIVE_ACCOUNT: return L"disconnect inactive account, try to logged in again";
		case Error::ERR_SESSION_NOT_FOUND: return L"ERR_SESSION_NOT_FOUND";
		case Error::ERR_WRONG_PARAMETER_ACCT_NAME: return L"wrong parameter";
		case Error::ERR_WRONG_PARAMETER_1: return L"wrong parameter: 1st";
		case Error::ERR_WRONG_PARAMETER_2: return L"wrong parameter: 2nd";
		case Error::ERR_WRONG_PARAMETER_3: return L"wrong parameter: 3rd";
		case Error::ERR_WRONG_PARAMETER_4: return L"wrong parameter: 4th";
		case Error::ERR_WRONG_PARAMETER_5: return L"wrong parameter: 5th";
		case Error::ERR_WRONG_PARAMETER_COST: return L"ERR_WRONG_PARAMETER_COST";
		case Error::ERR_WRONG_PARAMETER: return L"ERR_WRONG_PARAMETER";
		case Error::ERR_RESOURCE_NOT_FOUND: return L"resource not found";
		case Error::ERR_RESOURCE_NOT_FOUND_SOURCE: return L"resource not found(source)";
		case Error::ERR_RESOURCE_NOT_FOUND_TARGET: return L"resource not found(target)";
		case Error::ERR_ACCESS_DENIED: return L"acess denied";
		case Error::ERR_ACCESS_DENIED_PROTECTED: return L"acess denied: protected";
		case Error::ERR_ACCESS_DENIED_SOURCE: return L"ERR_ACCESS_DENIED_SOURCE";
		case Error::ERR_ACCESS_DENIED_TARGET: return L"ERR_ACCESS_DENIED_TARGET";
		case Error::ERR_DB_SERVER: return L"DB ERROR";
		case Error::ERR_DB_SERVER_SQLEXCEPTION: return L"db error";
		case Error::ERR_DB_SERVER_SQLWARNING: return L"db error";
		case Error::ERR_INSURFFICIENT_RESOURCE: return L"ERR_INSURFFICIENT_RESOURCE";
		case Error::ERR_INSURFFICIENT_GAME_MONEY: return L"ERR_INSURFFICIENT_GAME_MONEY";
		case Error::ERR_INSURFFICIENT_GAME_CASH: return L"ERR_INSURFFICIENT_GAME_CASH";
		case Error::ERR_INSURFFICIENT_HONOR_POINT: return L"ERR_INSURFFICIENT_HONOR_POINT";
		case Error::ERR_INSURFFICIENT_AP: return L"ERR_INSURFFICIENT_AP";
		case Error::ERR_INSURFFICIENT_ITEM_MATERIAL: return L"ERR_INSURFFICIENT_ITEM_MATERIAL";
		case Error::ERR_INSURFFICIENT_INVENTORY: return L"ERR_INSURFFICIENT_INVENTORY";
		case Error::ERR_OPERATION_NOT_READY: return L"need to wait cool time";
		case Error::ERR_ACCOUNT_EVENT_RAISED: return L"AccountEvent should be resolved by ResolveAccountEventReq";
		case Error::ERR_ACCOUNT_EVENT_NOT_FOUND: return L"ERR_ACCOUNT_EVENT_NOT_FOUND";
		}
		return L"Error::UNDEFINED";
	}
	template < typename CharType >
	inline const CharType* T_Error_AsDesc(Error r);
	template <>
	inline const char* T_Error_AsDesc(Error r) { return Error_AsDescA(r); }
	template <>
	inline const wchar_t* T_Error_AsDesc(Error r) { return Error_AsDescW(r); }
	inline const TCHAR* Error_AsDesc(Error r) { return T_Error_AsDesc<TCHAR>(r); }
// explicits copy structs
	// client copy_from
	struct client_account {
		template < typename U, typename V > // packet to packet
		static void copy(const U& from, V& to) {
			to.acct_id = from.acct_id; // CT_PRIMITIVE
			to.acct_id_external = from.acct_id_external; // CT_PRIMITIVE
			to.acct_name = from.acct_name; // CT_STRING
			to.nickname = from.nickname; // CT_STRING
			to.creation_time = from.creation_time; // CT_TIMESTAMP
		}
		template < typename DB, typename T > // db to packet
		static void copy_from( const DB& from, T& to ) {
			to.acct_id = from.acct_id; // CT_PRIMITIVE
			to.acct_id_external = from.acct_id_external; // CT_PRIMITIVE
			to.acct_name = from.acct_name.c_str(); // CT_STRING
			to.nickname = from.nickname.c_str(); // CT_STRING
			oTLA::time_db_to_timestamp(to.creation_time, from.creation_time, (float)0, (float)9); // CT_TIMESTAMP
		}
		template < typename DB, typename T > // packet to db
		static void copy_to( const T& from, DB& to ) {
			to.acct_id = from.acct_id; // CT_PRIMITIVE
			to.acct_id_external = from.acct_id_external; // CT_PRIMITIVE
			to.acct_name = from.acct_name.c_str(); // CT_STRING
			to.nickname = from.nickname.c_str(); // CT_STRING
			oTLA::time_timestamp_to_db(to.creation_time, from.creation_time, (float)9, (float)0); // CT_TIMESTAMP
		}
	};
	
	/****************************************************************************
	*
	*	table: tbl_account
	*/
	
	struct tbl_account
	{
		static const char* name_A() { return "tbl_account"; }
		static const wchar_t* name_W() { return L"tbl_account"; };
		static const TCHAR* name() { return _T("tbl_account"); };

		static std::basic_string<TCHAR> table_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_game"), name()).AsString();
		}

		struct table_t {
			std::uint64_t acct_id; // bigint; 계정 Unique no
			std::uint64_t acct_id_external; // bigint; 
			corn::TFixedStringA<50> acct_name; // varchar; 
			corn::TFixedStringA<50> nickname; // varchar; 
			oTLA::DB_Time_t creation_time; // timestamp; 

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, acct_id, "acct_id")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, acct_id_external, "acct_id_external")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, acct_name, "acct_name")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, nickname, "nickname")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, creation_time, "creation_time")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
				to.acct_id_external = from.acct_id_external; // CT_PRIMITIVE
				to.acct_name = from.acct_name; // CT_STRING
				to.nickname = from.nickname; // CT_STRING
				to.creation_time = from.creation_time; // CT_TIMESTAMP
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
				to.acct_id_external = from.acct_id_external; // CT_PRIMITIVE
				to.acct_name = from.acct_name.c_str(); // CT_STRING
				to.nickname = from.nickname.c_str(); // CT_STRING
				oTLA::time_db_to_timestamp(to.creation_time, from.creation_time, (float)0, (float)9); // CT_TIMESTAMP
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
				to.acct_id_external = from.acct_id_external; // CT_PRIMITIVE
				to.acct_name = from.acct_name.c_str(); // CT_STRING
				to.nickname = from.nickname.c_str(); // CT_STRING
				oTLA::time_timestamp_to_db(to.creation_time, from.creation_time, (float)9, (float)0); // CT_TIMESTAMP
			}
		};
		// where clause classes
		struct PK_by_acct_id { // PRIMARY_KEY
			std::uint64_t acct_id; // bigint
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, acct_id, "acct_id")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
			}
		};
		struct K_by_acct_id_external { // KEY
			std::uint64_t acct_id_external; // bigint
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, acct_id_external, "acct_id_external")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.acct_id_external = from.acct_id_external; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.acct_id_external = from.acct_id_external; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.acct_id_external = from.acct_id_external; // CT_PRIMITIVE
			}
		};
		struct K_by_acct_name { // KEY
			corn::TFixedStringA<50> acct_name; // varchar
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, acct_name, "acct_name")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.acct_name = from.acct_name; // CT_STRING
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.acct_name = from.acct_name.c_str(); // CT_STRING
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.acct_name = from.acct_name.c_str(); // CT_STRING
			}
		};
		struct PK_by_all { // PRIMARY_KEY_ALL
			std::uint64_t acct_id; // bigint

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, acct_id, "acct_id")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
			}
		};

		template < typename DB >
		static oTLA::Persist<table_t> persist(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::Persist<table_t> u(db, table_name(db_name).c_str() );
			return std::move(u);
		}

		template < typename DB, typename Where >
		static oTLA::search_t<table_t, DB,Where> search(DB* db, const Where& where, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, Where> u(db, table_name(db_name).c_str(), where);
			return std::move(u);
		}

		template < typename DB >
		static oTLA::search_t<table_t, DB, oTLA::NullWhereClause> search(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, oTLA::NullWhereClause> u(db, table_name(db_name).c_str(), oTLA::NullWhereClause());
			return std::move(u);
		}
		
	};

	/****************************************************************************
	*
	*	table: tbl_account_game
	*/
	
	struct tbl_account_game
	{
		static const char* name_A() { return "tbl_account_game"; }
		static const wchar_t* name_W() { return L"tbl_account_game"; };
		static const TCHAR* name() { return _T("tbl_account_game"); };

		static std::basic_string<TCHAR> table_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_game"), name()).AsString();
		}

		struct table_t {
			std::uint64_t acct_id; // bigint; 
			std::uint32_t acct_level; // int; 
			std::uint32_t acct_exp; // int; 
			std::uint64_t curr_char_id; // bigint; 
			std::uint32_t gold; // int; 
			std::uint32_t ruby; // int; 
			std::uint32_t max_ap; // int; 최대 행동력
			oTLA::DB_Time_t time_to_max_ap; // timestamp; ap가 최대치가 될 시간
			std::uint32_t ap_cool_time; // int; ap 쿨타임(1차는데 걸리는 초)
			oTLA::DB_Time_t last_logged_in; // timestamp; 
			std::uint32_t max_inventory_count; // int; 
			std::uint32_t last_processed_system_mail_id; // int; 
			static const auto time_to_free_product__max_size = 10;
			oTLA::DB_Time_t time_to_free_product[10]; // timestamp; 
			std::uint32_t max_box_inventory_count; // int; 

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, acct_id, "acct_id")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, acct_level, "acct_level")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, acct_exp, "acct_exp")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, curr_char_id, "curr_char_id")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, gold, "gold")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, ruby, "ruby")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, max_ap, "max_ap")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, time_to_max_ap, "time_to_max_ap")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, ap_cool_time, "ap_cool_time")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, last_logged_in, "last_logged_in")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, max_inventory_count, "max_inventory_count")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, last_processed_system_mail_id, "last_processed_system_mail_id")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, time_to_free_product[0], "time_to_free_product_0")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, time_to_free_product[1], "time_to_free_product_1")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, time_to_free_product[2], "time_to_free_product_2")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, time_to_free_product[3], "time_to_free_product_3")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, time_to_free_product[4], "time_to_free_product_4")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, time_to_free_product[5], "time_to_free_product_5")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, time_to_free_product[6], "time_to_free_product_6")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, time_to_free_product[7], "time_to_free_product_7")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, time_to_free_product[8], "time_to_free_product_8")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, time_to_free_product[9], "time_to_free_product_9")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, max_box_inventory_count, "max_box_inventory_count")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
				to.acct_level = from.acct_level; // CT_PRIMITIVE
				to.acct_exp = from.acct_exp; // CT_PRIMITIVE
				to.curr_char_id = from.curr_char_id; // CT_PRIMITIVE
				to.gold = from.gold; // CT_PRIMITIVE
				to.ruby = from.ruby; // CT_PRIMITIVE
				to.max_ap = from.max_ap; // CT_PRIMITIVE
				to.time_to_max_ap = from.time_to_max_ap; // CT_TIMESTAMP
				to.ap_cool_time = from.ap_cool_time; // CT_PRIMITIVE
				to.last_logged_in = from.last_logged_in; // CT_TIMESTAMP
				to.max_inventory_count = from.max_inventory_count; // CT_PRIMITIVE
				to.last_processed_system_mail_id = from.last_processed_system_mail_id; // CT_PRIMITIVE
				for ( int i = 0; i < 10; ++i )
					to.time_to_free_product[i] = from.time_to_free_product[i]; // CT_TIMESTAMP
				to.max_box_inventory_count = from.max_box_inventory_count; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
				to.acct_level = from.acct_level; // CT_PRIMITIVE
				to.acct_exp = from.acct_exp; // CT_PRIMITIVE
				to.curr_char_id = from.curr_char_id; // CT_PRIMITIVE
				to.gold = from.gold; // CT_PRIMITIVE
				to.ruby = from.ruby; // CT_PRIMITIVE
				to.max_ap = from.max_ap; // CT_PRIMITIVE
				oTLA::time_db_to_timestamp(to.time_to_max_ap, from.time_to_max_ap, (float)0, (float)9); // CT_TIMESTAMP
				to.ap_cool_time = from.ap_cool_time; // CT_PRIMITIVE
				oTLA::time_db_to_timestamp(to.last_logged_in, from.last_logged_in, (float)0, (float)9); // CT_TIMESTAMP
				to.max_inventory_count = from.max_inventory_count; // CT_PRIMITIVE
				to.last_processed_system_mail_id = from.last_processed_system_mail_id; // CT_PRIMITIVE
				for ( int i = 0; i < 10; ++i )
					oTLA::time_db_to_timestamp(to.time_to_free_product[i], from.time_to_free_product[i], (float)0, (float)9); // CT_TIMESTAMP
				to.max_box_inventory_count = from.max_box_inventory_count; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
				to.acct_level = from.acct_level; // CT_PRIMITIVE
				to.acct_exp = from.acct_exp; // CT_PRIMITIVE
				to.curr_char_id = from.curr_char_id; // CT_PRIMITIVE
				to.gold = from.gold; // CT_PRIMITIVE
				to.ruby = from.ruby; // CT_PRIMITIVE
				to.max_ap = from.max_ap; // CT_PRIMITIVE
				oTLA::time_timestamp_to_db(to.time_to_max_ap, from.time_to_max_ap, (float)9, (float)0); // CT_TIMESTAMP
				to.ap_cool_time = from.ap_cool_time; // CT_PRIMITIVE
				oTLA::time_timestamp_to_db(to.last_logged_in, from.last_logged_in, (float)9, (float)0); // CT_TIMESTAMP
				to.max_inventory_count = from.max_inventory_count; // CT_PRIMITIVE
				to.last_processed_system_mail_id = from.last_processed_system_mail_id; // CT_PRIMITIVE
				for ( int i = 0; i < 10; ++i )
					oTLA::time_db_to_timestamp(to.time_to_free_product[i], from.time_to_free_product[i], (float)9, (float)0);; // CT_TIMESTAMP
				to.max_box_inventory_count = from.max_box_inventory_count; // CT_PRIMITIVE
			}
		};
		// where clause classes
		struct PK_by_acct_id { // PRIMARY_KEY
			std::uint64_t acct_id; // bigint
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, acct_id, "acct_id")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
			}
		};
		struct PK_by_all { // PRIMARY_KEY_ALL
			std::uint64_t acct_id; // bigint

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, acct_id, "acct_id")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
			}
		};

		template < typename DB >
		static oTLA::Persist<table_t> persist(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::Persist<table_t> u(db, table_name(db_name).c_str() );
			return std::move(u);
		}

		template < typename DB, typename Where >
		static oTLA::search_t<table_t, DB,Where> search(DB* db, const Where& where, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, Where> u(db, table_name(db_name).c_str(), where);
			return std::move(u);
		}

		template < typename DB >
		static oTLA::search_t<table_t, DB, oTLA::NullWhereClause> search(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, oTLA::NullWhereClause> u(db, table_name(db_name).c_str(), oTLA::NullWhereClause());
			return std::move(u);
		}
		
	};

	/****************************************************************************
	*
	*	table: tbl_character
	*/
	
	struct tbl_character
	{
		static const char* name_A() { return "tbl_character"; }
		static const wchar_t* name_W() { return L"tbl_character"; };
		static const TCHAR* name() { return _T("tbl_character"); };

		static std::basic_string<TCHAR> table_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_game"), name()).AsString();
		}

		struct table_t {
			std::uint64_t acct_id; // bigint; 
			std::uint64_t char_id; // bigint; 
			std::uint32_t char_index; // int; 
			std::uint32_t char_level; // int; 
			std::uint32_t char_exp; // int; 
			static const auto char_attr_pt__max_size = 4;
			std::uint32_t char_attr_pt[4]; // int; 0:att,def,health,ai
			corn::TFixedStringA<20> char_spec; // varchar; sepc string: 010021304201102
			static const auto slot_item_id__max_size = 10;
			std::uint64_t slot_item_id[10]; // bigint; 0: char_skin 1:weapon
			static const auto slot_item_skill_id__max_size = 10;
			std::uint64_t slot_item_skill_id[10]; // bigint; 

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, acct_id, "acct_id")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_id, "char_id")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_index, "char_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_level, "char_level")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_exp, "char_exp")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_attr_pt[0], "char_attr_pt_0")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_attr_pt[1], "char_attr_pt_1")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_attr_pt[2], "char_attr_pt_2")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_attr_pt[3], "char_attr_pt_3")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_spec, "char_spec")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_id[0], "slot_item_id_0")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_id[1], "slot_item_id_1")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_id[2], "slot_item_id_2")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_id[3], "slot_item_id_3")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_id[4], "slot_item_id_4")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_id[5], "slot_item_id_5")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_id[6], "slot_item_id_6")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_id[7], "slot_item_id_7")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_id[8], "slot_item_id_8")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_id[9], "slot_item_id_9")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_skill_id[0], "slot_item_skill_id_0")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_skill_id[1], "slot_item_skill_id_1")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_skill_id[2], "slot_item_skill_id_2")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_skill_id[3], "slot_item_skill_id_3")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_skill_id[4], "slot_item_skill_id_4")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_skill_id[5], "slot_item_skill_id_5")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_skill_id[6], "slot_item_skill_id_6")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_skill_id[7], "slot_item_skill_id_7")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_skill_id[8], "slot_item_skill_id_8")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot_item_skill_id[9], "slot_item_skill_id_9")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
				to.char_id = from.char_id; // CT_PRIMITIVE
				to.char_index = from.char_index; // CT_PRIMITIVE
				to.char_level = from.char_level; // CT_PRIMITIVE
				to.char_exp = from.char_exp; // CT_PRIMITIVE
				for ( int i = 0; i < 4; ++i )
					to.char_attr_pt[i] = from.char_attr_pt[i]; // CT_PRIMITIVE[]
				to.char_spec = from.char_spec; // CT_STRING
				for ( int i = 0; i < 10; ++i )
					to.slot_item_id[i] = from.slot_item_id[i]; // CT_PRIMITIVE[]
				for ( int i = 0; i < 10; ++i )
					to.slot_item_skill_id[i] = from.slot_item_skill_id[i]; // CT_PRIMITIVE[]
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
				to.char_id = from.char_id; // CT_PRIMITIVE
				to.char_index = from.char_index; // CT_PRIMITIVE
				to.char_level = from.char_level; // CT_PRIMITIVE
				to.char_exp = from.char_exp; // CT_PRIMITIVE
				for ( int i = 0; i < 4; ++i )
					to.char_attr_pt[i] = from.char_attr_pt[i]; // CT_PRIMITIVE[]
				to.char_spec = from.char_spec.c_str(); // CT_STRING
				for ( int i = 0; i < 10; ++i )
					to.slot_item_id[i] = from.slot_item_id[i]; // CT_PRIMITIVE[]
				for ( int i = 0; i < 10; ++i )
					to.slot_item_skill_id[i] = from.slot_item_skill_id[i]; // CT_PRIMITIVE[]
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.acct_id = from.acct_id; // CT_PRIMITIVE
				to.char_id = from.char_id; // CT_PRIMITIVE
				to.char_index = from.char_index; // CT_PRIMITIVE
				to.char_level = from.char_level; // CT_PRIMITIVE
				to.char_exp = from.char_exp; // CT_PRIMITIVE
				for ( int i = 0; i < 4; ++i )
					to.char_attr_pt[i] = from.char_attr_pt[i]; // CT_PRIMITIVE[]
				to.char_spec = from.char_spec.c_str(); // CT_STRING
				for ( int i = 0; i < 10; ++i )
					to.slot_item_id[i] = from.slot_item_id[i]; // CT_PRIMITIVE[]
				for ( int i = 0; i < 10; ++i )
					to.slot_item_skill_id[i] = from.slot_item_skill_id[i]; // CT_PRIMITIVE[]
			}
		};
		// where clause classes
		struct PK_by_char_id { // PRIMARY_KEY
			std::uint64_t char_id; // bigint
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, char_id, "char_id")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.char_id = from.char_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.char_id = from.char_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.char_id = from.char_id; // CT_PRIMITIVE
			}
		};
		struct PK_by_all { // PRIMARY_KEY_ALL
			std::uint64_t char_id; // bigint

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, char_id, "char_id")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.char_id = from.char_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.char_id = from.char_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.char_id = from.char_id; // CT_PRIMITIVE
			}
		};

		template < typename DB >
		static oTLA::Persist<table_t> persist(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::Persist<table_t> u(db, table_name(db_name).c_str() );
			return std::move(u);
		}

		template < typename DB, typename Where >
		static oTLA::search_t<table_t, DB,Where> search(DB* db, const Where& where, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, Where> u(db, table_name(db_name).c_str(), where);
			return std::move(u);
		}

		template < typename DB >
		static oTLA::search_t<table_t, DB, oTLA::NullWhereClause> search(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, oTLA::NullWhereClause> u(db, table_name(db_name).c_str(), oTLA::NullWhereClause());
			return std::move(u);
		}
		
	};

	/****************************************************************************
	*
	*	table: tbl_log_db
	*/
	
	struct tbl_log_db
	{
		static const char* name_A() { return "tbl_log_db"; }
		static const wchar_t* name_W() { return L"tbl_log_db"; };
		static const TCHAR* name() { return _T("tbl_log_db"); };

		static std::basic_string<TCHAR> table_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_game"), name()).AsString();
		}

		struct table_t {
			std::uint64_t log_id; // bigint; 
			oTLA::DB_Time_t log_time; // timestamp; 
			corn::TFixedStringA<512> msg; // varchar; 

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, log_id, "log_id")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, log_time, "log_time")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, msg, "msg")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.log_id = from.log_id; // CT_PRIMITIVE
				to.log_time = from.log_time; // CT_TIMESTAMP
				to.msg = from.msg; // CT_STRING
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.log_id = from.log_id; // CT_PRIMITIVE
				oTLA::time_db_to_timestamp(to.log_time, from.log_time, (float)0, (float)9); // CT_TIMESTAMP
				to.msg = from.msg.c_str(); // CT_STRING
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.log_id = from.log_id; // CT_PRIMITIVE
				oTLA::time_timestamp_to_db(to.log_time, from.log_time, (float)9, (float)0); // CT_TIMESTAMP
				to.msg = from.msg.c_str(); // CT_STRING
			}
		};
		// where clause classes
		struct PK_by_log_id { // PRIMARY_KEY
			std::uint64_t log_id; // bigint
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, log_id, "log_id")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.log_id = from.log_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.log_id = from.log_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.log_id = from.log_id; // CT_PRIMITIVE
			}
		};
		struct PK_by_all { // PRIMARY_KEY_ALL
			std::uint64_t log_id; // bigint

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, log_id, "log_id")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.log_id = from.log_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.log_id = from.log_id; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.log_id = from.log_id; // CT_PRIMITIVE
			}
		};

		template < typename DB >
		static oTLA::Persist<table_t> persist(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::Persist<table_t> u(db, table_name(db_name).c_str() );
			return std::move(u);
		}

		template < typename DB, typename Where >
		static oTLA::search_t<table_t, DB,Where> search(DB* db, const Where& where, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, Where> u(db, table_name(db_name).c_str(), where);
			return std::move(u);
		}

		template < typename DB >
		static oTLA::search_t<table_t, DB, oTLA::NullWhereClause> search(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, oTLA::NullWhereClause> u(db, table_name(db_name).c_str(), oTLA::NullWhereClause());
			return std::move(u);
		}
		
	};

	/****************************************************************************
	*
	*	stored procedure: sp_get_account_box
	*/
	struct sp_get_account_box
	{
		static const char* name_A() { return "sp_get_account_box"; }
		static const wchar_t* name_W() { return L"sp_get_account_box"; };
		static const TCHAR* name() { return _T("sp_get_account_box"); };

		static std::basic_string<TCHAR> sp_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_game"), name()).AsString();
		}

		struct sp_t {
			struct {
				std::uint64_t acct_id; // bigint

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.acct_id = from.acct_id; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.acct_id = from.acct_id; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.acct_id = from.acct_id; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("acct_id") << _T(":") << acct_id;
					return ss.str();
				}
			} in;

			struct out_t {
				std::uint32_t result; // int

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, result, "result")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("result") << _T(":") << result;
					return ss.str();
				}
			} out;

			struct result_set_t {
				std::uint64_t acct_id; // bigint
				static const auto box_type__max_size = 10;
				std::uint32_t box_type[10]; // int
				static const auto box_arena_tier__max_size = 10;
				std::uint32_t box_arena_tier[10]; // int
				static const auto time_to_unlock__max_size = 10;
				oTLA::DB_Time_t time_to_unlock[10]; // timestamp

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, acct_id, "acct_id")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_type[0], "box_type_0")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_type[1], "box_type_1")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_type[2], "box_type_2")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_type[3], "box_type_3")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_type[4], "box_type_4")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_type[5], "box_type_5")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_type[6], "box_type_6")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_type[7], "box_type_7")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_type[8], "box_type_8")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_type[9], "box_type_9")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_arena_tier[0], "box_arena_tier_0")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_arena_tier[1], "box_arena_tier_1")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_arena_tier[2], "box_arena_tier_2")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_arena_tier[3], "box_arena_tier_3")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_arena_tier[4], "box_arena_tier_4")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_arena_tier[5], "box_arena_tier_5")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_arena_tier[6], "box_arena_tier_6")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_arena_tier[7], "box_arena_tier_7")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_arena_tier[8], "box_arena_tier_8")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, box_arena_tier[9], "box_arena_tier_9")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, time_to_unlock[0], "time_to_unlock_0")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, time_to_unlock[1], "time_to_unlock_1")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, time_to_unlock[2], "time_to_unlock_2")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, time_to_unlock[3], "time_to_unlock_3")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, time_to_unlock[4], "time_to_unlock_4")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, time_to_unlock[5], "time_to_unlock_5")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, time_to_unlock[6], "time_to_unlock_6")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, time_to_unlock[7], "time_to_unlock_7")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, time_to_unlock[8], "time_to_unlock_8")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, time_to_unlock[9], "time_to_unlock_9")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.acct_id = from.acct_id; // CT_PRIMITIVE
					for ( int i = 0; i < 10; ++i )
						to.box_type[i] = from.box_type[i]; // CT_PRIMITIVE[]
					for ( int i = 0; i < 10; ++i )
						to.box_arena_tier[i] = from.box_arena_tier[i]; // CT_PRIMITIVE[]
					for ( int i = 0; i < 10; ++i )
						to.time_to_unlock[i] = from.time_to_unlock[i]; // CT_TIMESTAMP
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.acct_id = from.acct_id; // CT_PRIMITIVE
					for ( int i = 0; i < 10; ++i )
						to.box_type[i] = from.box_type[i]; // CT_PRIMITIVE[]
					for ( int i = 0; i < 10; ++i )
						to.box_arena_tier[i] = from.box_arena_tier[i]; // CT_PRIMITIVE[]
					for ( int i = 0; i < 10; ++i )
						oTLA::time_db_to_timestamp(to.time_to_unlock[i], from.time_to_unlock[i], (float)0, (float)9); // CT_TIMESTAMP
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.acct_id = from.acct_id; // CT_PRIMITIVE
					for ( int i = 0; i < 10; ++i )
						to.box_type[i] = from.box_type[i]; // CT_PRIMITIVE[]
					for ( int i = 0; i < 10; ++i )
						to.box_arena_tier[i] = from.box_arena_tier[i]; // CT_PRIMITIVE[]
					for ( int i = 0; i < 10; ++i )
						oTLA::time_db_to_timestamp(to.time_to_unlock[i], from.time_to_unlock[i], (float)9, (float)0);; // CT_TIMESTAMP
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("acct_id") << _T(":") << acct_id;
					ss << _T(" in.") << _T("box_type[0]") << _T(":") << box_type[0];
					ss << _T(" in.") << _T("box_type[1]") << _T(":") << box_type[1];
					ss << _T(" in.") << _T("box_type[2]") << _T(":") << box_type[2];
					ss << _T(" in.") << _T("box_type[3]") << _T(":") << box_type[3];
					ss << _T(" in.") << _T("box_type[4]") << _T(":") << box_type[4];
					ss << _T(" in.") << _T("box_type[5]") << _T(":") << box_type[5];
					ss << _T(" in.") << _T("box_type[6]") << _T(":") << box_type[6];
					ss << _T(" in.") << _T("box_type[7]") << _T(":") << box_type[7];
					ss << _T(" in.") << _T("box_type[8]") << _T(":") << box_type[8];
					ss << _T(" in.") << _T("box_type[9]") << _T(":") << box_type[9];
					ss << _T(" in.") << _T("box_arena_tier[0]") << _T(":") << box_arena_tier[0];
					ss << _T(" in.") << _T("box_arena_tier[1]") << _T(":") << box_arena_tier[1];
					ss << _T(" in.") << _T("box_arena_tier[2]") << _T(":") << box_arena_tier[2];
					ss << _T(" in.") << _T("box_arena_tier[3]") << _T(":") << box_arena_tier[3];
					ss << _T(" in.") << _T("box_arena_tier[4]") << _T(":") << box_arena_tier[4];
					ss << _T(" in.") << _T("box_arena_tier[5]") << _T(":") << box_arena_tier[5];
					ss << _T(" in.") << _T("box_arena_tier[6]") << _T(":") << box_arena_tier[6];
					ss << _T(" in.") << _T("box_arena_tier[7]") << _T(":") << box_arena_tier[7];
					ss << _T(" in.") << _T("box_arena_tier[8]") << _T(":") << box_arena_tier[8];
					ss << _T(" in.") << _T("box_arena_tier[9]") << _T(":") << box_arena_tier[9];
					ss << _T(" in.") << _T("time_to_unlock[0]") << _T(":") << time_to_unlock[0];
					ss << _T(" in.") << _T("time_to_unlock[1]") << _T(":") << time_to_unlock[1];
					ss << _T(" in.") << _T("time_to_unlock[2]") << _T(":") << time_to_unlock[2];
					ss << _T(" in.") << _T("time_to_unlock[3]") << _T(":") << time_to_unlock[3];
					ss << _T(" in.") << _T("time_to_unlock[4]") << _T(":") << time_to_unlock[4];
					ss << _T(" in.") << _T("time_to_unlock[5]") << _T(":") << time_to_unlock[5];
					ss << _T(" in.") << _T("time_to_unlock[6]") << _T(":") << time_to_unlock[6];
					ss << _T(" in.") << _T("time_to_unlock[7]") << _T(":") << time_to_unlock[7];
					ss << _T(" in.") << _T("time_to_unlock[8]") << _T(":") << time_to_unlock[8];
					ss << _T(" in.") << _T("time_to_unlock[9]") << _T(":") << time_to_unlock[9];
					return ss.str();
				}
			};

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.acct_id, "acct_id")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.result, "result")
			END_OTLA_BINDING
		}; // struct sp {

		//
		oTLA::StoredProcedure<sp_t> sp;
		oTLA::Search<sp_t::out_t> out;
		oTLA::Search<sp_t::result_set_t> result;
		oTLA::Search<sp_t::result_set_t> result_end;

		struct result_iterator {
			oTLA::Search<sp_t::result_set_t>* s_;
			result_iterator(oTLA::Search<sp_t::result_set_t>* s) : s_(s) {}			
			oTLA::Search<sp_t::result_set_t>::reference operator*() const { return *(*s_); }
			oTLA::Search<sp_t::result_set_t>::pointer operator->() const { return (*s_).operator->(); }
			bool operator!= (const result_iterator & rhs) const { return (*s_) != (*rhs.s_); }
			result_iterator& operator++() { ++(*s_); return *this; }
		};
		result_iterator begin() {
			return result_iterator(&result);
		}
		result_iterator end() {
			return result_iterator(&result_end);
		}
		int size() const {
			return result.Get_Row_Processed_Count();
		}
		
		template < typename UPDATER >
		void open( UPDATER* u, const TCHAR* db_name = nullptr )
		{
			result.SetExternalResultStream(sp.Get_Result_Stream());
			sp.Open(u, sp_name(db_name).c_str(), result);
			out.Open(u,nullptr);
		}
		template < typename T_acct_id >
		explicit sp_get_account_box( char _dummy, const T_acct_id& acct_id ) {
			sp->in.acct_id = acct_id; // DEFAULT
		}
		template < typename T_acct_id >
		void init( const T_acct_id& acct_id ) {
			sp->in.acct_id = acct_id; // DEFAULT
		}
		template < typename PacketType >
		explicit sp_get_account_box( const PacketType* p ) {
			init( 
				p->acct_id
			);
		}
	private:
		sp_get_account_box() = delete;
	};
	/****************************************************************************
	*
	*	stored procedure: sp_account_login
	*/
	struct sp_account_login
	{
		static const char* name_A() { return "sp_account_login"; }
		static const wchar_t* name_W() { return L"sp_account_login"; };
		static const TCHAR* name() { return _T("sp_account_login"); };

		static std::basic_string<TCHAR> sp_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_game"), name()).AsString();
		}

		struct sp_t {
			struct {
				corn::TFixedStringA<50> acct_name; // varchar
				corn::TFixedStringA<50> ip_address; // varchar
				std::uint32_t port; // int

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.acct_name = from.acct_name; // CT_STRING
					to.ip_address = from.ip_address; // CT_STRING
					to.port = from.port; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.acct_name = from.acct_name.c_str(); // CT_STRING
					to.ip_address = from.ip_address.c_str(); // CT_STRING
					to.port = from.port; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.acct_name = from.acct_name.c_str(); // CT_STRING
					to.ip_address = from.ip_address.c_str(); // CT_STRING
					to.port = from.port; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("acct_name") << _T(":") << acct_name.c_str();
					ss << _T(" in.") << _T("ip_address") << _T(":") << ip_address.c_str();
					ss << _T(" in.") << _T("port") << _T(":") << port;
					return ss.str();
				}
			} in;

			struct out_t {
				std::uint32_t result; // int

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, result, "result")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("result") << _T(":") << result;
					return ss.str();
				}
			} out;


			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.acct_name, "acct_name")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.ip_address, "ip_address")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.port, "port")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.result, "result")
			END_OTLA_BINDING
		}; // struct sp {

		//
		oTLA::StoredProcedure<sp_t> sp;
		oTLA::Search<sp_t::out_t> out;
		
		template < typename UPDATER >
		void open( UPDATER* u, const TCHAR* db_name = nullptr )
		{
			sp.Open(u, sp_name(db_name).c_str());
			out.Open(u,nullptr);
		}
		template < typename T_acct_name, typename T_ip_address, typename T_port >
		explicit sp_account_login( char _dummy, const T_acct_name& acct_name, const T_ip_address& ip_address, const T_port& port ) {
			sp->in.acct_name = acct_name; // DEFAULT
			sp->in.ip_address = ip_address; // DEFAULT
			sp->in.port = port; // DEFAULT
		}
		template < typename T_acct_name, typename T_ip_address, typename T_port >
		void init( const T_acct_name& acct_name, const T_ip_address& ip_address, const T_port& port ) {
			sp->in.acct_name = acct_name; // DEFAULT
			sp->in.ip_address = ip_address; // DEFAULT
			sp->in.port = port; // DEFAULT
		}
		template < typename PacketType >
		explicit sp_account_login( const PacketType* p ) {
			init( 
				p->acct_name, p->ip_address, p->port
			);
		}
	private:
		sp_account_login() = delete;
	};
	/****************************************************************************
	*
	*	stored procedure: sp_new_item_list
	*/
	struct sp_new_item_list
	{
		static const char* name_A() { return "sp_new_item_list"; }
		static const wchar_t* name_W() { return L"sp_new_item_list"; };
		static const TCHAR* name() { return _T("sp_new_item_list"); };

		static std::basic_string<TCHAR> sp_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_game"), name()).AsString();
		}

		struct sp_t {
			struct {
				std::uint64_t acct_id; // bigint
				static const auto new_item_index__max_size = 5;
				std::uint32_t new_item_index[5]; // int
				static const auto amount__max_size = 5;
				std::uint32_t amount[5]; // int

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.acct_id = from.acct_id; // CT_PRIMITIVE
					for ( int i = 0; i < 5; ++i )
						to.new_item_index[i] = from.new_item_index[i]; // CT_PRIMITIVE[]
					for ( int i = 0; i < 5; ++i )
						to.amount[i] = from.amount[i]; // CT_PRIMITIVE[]
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.acct_id = from.acct_id; // CT_PRIMITIVE
					for ( int i = 0; i < 5; ++i )
						to.new_item_index[i] = from.new_item_index[i]; // CT_PRIMITIVE[]
					for ( int i = 0; i < 5; ++i )
						to.amount[i] = from.amount[i]; // CT_PRIMITIVE[]
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.acct_id = from.acct_id; // CT_PRIMITIVE
					for ( int i = 0; i < 5; ++i )
						to.new_item_index[i] = from.new_item_index[i]; // CT_PRIMITIVE[]
					for ( int i = 0; i < 5; ++i )
						to.amount[i] = from.amount[i]; // CT_PRIMITIVE[]
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("acct_id") << _T(":") << acct_id;
					ss << _T(" in.") << _T("new_item_index[0]") << _T(":") << new_item_index[0];
					ss << _T(" in.") << _T("new_item_index[1]") << _T(":") << new_item_index[1];
					ss << _T(" in.") << _T("new_item_index[2]") << _T(":") << new_item_index[2];
					ss << _T(" in.") << _T("new_item_index[3]") << _T(":") << new_item_index[3];
					ss << _T(" in.") << _T("new_item_index[4]") << _T(":") << new_item_index[4];
					ss << _T(" in.") << _T("amount[0]") << _T(":") << amount[0];
					ss << _T(" in.") << _T("amount[1]") << _T(":") << amount[1];
					ss << _T(" in.") << _T("amount[2]") << _T(":") << amount[2];
					ss << _T(" in.") << _T("amount[3]") << _T(":") << amount[3];
					ss << _T(" in.") << _T("amount[4]") << _T(":") << amount[4];
					return ss.str();
				}
			} in;

			struct out_t {
				std::uint32_t result; // int
				std::uint32_t added_count; // int
				static const auto added_item_id__max_size = 5;
				std::uint64_t added_item_id[5]; // bigint

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, result, "result")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, added_count, "added_count")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, added_item_id[0], "added_item_id_0")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, added_item_id[1], "added_item_id_1")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, added_item_id[2], "added_item_id_2")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, added_item_id[3], "added_item_id_3")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, added_item_id[4], "added_item_id_4")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.result = from.result; // CT_PRIMITIVE
					to.added_count = from.added_count; // CT_PRIMITIVE
					for ( int i = 0; i < 5; ++i )
						to.added_item_id[i] = from.added_item_id[i]; // CT_PRIMITIVE[]
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.result = from.result; // CT_PRIMITIVE
					to.added_count = from.added_count; // CT_PRIMITIVE
					for ( int i = 0; i < 5; ++i )
						to.added_item_id[i] = from.added_item_id[i]; // CT_PRIMITIVE[]
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.result = from.result; // CT_PRIMITIVE
					to.added_count = from.added_count; // CT_PRIMITIVE
					for ( int i = 0; i < 5; ++i )
						to.added_item_id[i] = from.added_item_id[i]; // CT_PRIMITIVE[]
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("result") << _T(":") << result;
					ss << _T(" in.") << _T("added_count") << _T(":") << added_count;
					ss << _T(" in.") << _T("added_item_id[0]") << _T(":") << added_item_id[0];
					ss << _T(" in.") << _T("added_item_id[1]") << _T(":") << added_item_id[1];
					ss << _T(" in.") << _T("added_item_id[2]") << _T(":") << added_item_id[2];
					ss << _T(" in.") << _T("added_item_id[3]") << _T(":") << added_item_id[3];
					ss << _T(" in.") << _T("added_item_id[4]") << _T(":") << added_item_id[4];
					return ss.str();
				}
			} out;


			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.acct_id, "acct_id")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.new_item_index[0], "new_item_index_0")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.new_item_index[1], "new_item_index_1")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.new_item_index[2], "new_item_index_2")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.new_item_index[3], "new_item_index_3")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.new_item_index[4], "new_item_index_4")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.amount[0], "amount_0")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.amount[1], "amount_1")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.amount[2], "amount_2")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.amount[3], "amount_3")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.amount[4], "amount_4")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.result, "result")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.added_count, "added_count")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.added_item_id[0], "added_item_id_0")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.added_item_id[1], "added_item_id_1")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.added_item_id[2], "added_item_id_2")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.added_item_id[3], "added_item_id_3")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.added_item_id[4], "added_item_id_4")
			END_OTLA_BINDING
		}; // struct sp {

		//
		oTLA::StoredProcedure<sp_t> sp;
		oTLA::Search<sp_t::out_t> out;
		
		template < typename UPDATER >
		void open( UPDATER* u, const TCHAR* db_name = nullptr )
		{
			sp.Open(u, sp_name(db_name).c_str());
			out.Open(u,nullptr);
		}
		template < typename T_acct_id, unsigned int N_new_item_index, typename T_new_item_index, unsigned int N_amount, typename T_amount >
		explicit sp_new_item_list( char _dummy, const T_acct_id& acct_id, const T_new_item_index (&new_item_index)[N_new_item_index], const T_amount (&amount)[N_amount] ) {
			sp->in.acct_id = acct_id; // DEFAULT
			for ( unsigned int i = 0; i < N_new_item_index; ++i )
				sp->in.new_item_index[i] = new_item_index[i]; // DEFAULT
			for ( unsigned int i = 0; i < N_amount; ++i )
				sp->in.amount[i] = amount[i]; // DEFAULT
		}
		template < typename T_acct_id, unsigned int N_new_item_index, typename T_new_item_index, unsigned int N_amount, typename T_amount >
		void init( const T_acct_id& acct_id, const T_new_item_index (&new_item_index)[N_new_item_index], const T_amount (&amount)[N_amount] ) {
			sp->in.acct_id = acct_id; // DEFAULT
			for ( unsigned int i = 0; i < N_new_item_index; ++i )
				sp->in.new_item_index[i] = new_item_index[i]; // DEFAULT
			for ( unsigned int i = 0; i < N_amount; ++i )
				sp->in.amount[i] = amount[i]; // DEFAULT
		}
		template < typename PacketType >
		explicit sp_new_item_list( const PacketType* p ) {
			init( 
				p->acct_id, p->new_item_index, p->amount
			);
		}
	private:
		sp_new_item_list() = delete;
	};
	/****************************************************************************
	*
	*	stored procedure: fn_new_item
	*/
	struct fn_new_item
	{
		static const char* name_A() { return "fn_new_item"; }
		static const wchar_t* name_W() { return L"fn_new_item"; };
		static const TCHAR* name() { return _T("fn_new_item"); };

		static std::basic_string<TCHAR> sp_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_game"), name()).AsString();
		}

		struct sp_t {
			struct {
				std::uint64_t in_acct_id; // bigint
				std::uint32_t new_item_index; // int
				std::uint32_t amount; // int

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.in_acct_id = from.in_acct_id; // CT_PRIMITIVE
					to.new_item_index = from.new_item_index; // CT_PRIMITIVE
					to.amount = from.amount; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.in_acct_id = from.in_acct_id; // CT_PRIMITIVE
					to.new_item_index = from.new_item_index; // CT_PRIMITIVE
					to.amount = from.amount; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.in_acct_id = from.in_acct_id; // CT_PRIMITIVE
					to.new_item_index = from.new_item_index; // CT_PRIMITIVE
					to.amount = from.amount; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("in_acct_id") << _T(":") << in_acct_id;
					ss << _T(" in.") << _T("new_item_index") << _T(":") << new_item_index;
					ss << _T(" in.") << _T("amount") << _T(":") << amount;
					return ss.str();
				}
			} in;

			struct out_t {
				std::uint32_t result; // int
				std::uint64_t added_item_id; // bigint

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, result, "result")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, added_item_id, "added_item_id")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.result = from.result; // CT_PRIMITIVE
					to.added_item_id = from.added_item_id; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.result = from.result; // CT_PRIMITIVE
					to.added_item_id = from.added_item_id; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.result = from.result; // CT_PRIMITIVE
					to.added_item_id = from.added_item_id; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("result") << _T(":") << result;
					ss << _T(" in.") << _T("added_item_id") << _T(":") << added_item_id;
					return ss.str();
				}
			} out;


			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.in_acct_id, "in_acct_id")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.new_item_index, "new_item_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.amount, "amount")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.result, "result")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.added_item_id, "added_item_id")
			END_OTLA_BINDING
		}; // struct sp {

		//
		oTLA::StoredProcedure<sp_t> sp;
		oTLA::Search<sp_t::out_t> out;
		
		template < typename UPDATER >
		void open( UPDATER* u, const TCHAR* db_name = nullptr )
		{
			sp.Open(u, sp_name(db_name).c_str());
			out.Open(u,nullptr);
		}
		template < typename T_in_acct_id, typename T_new_item_index, typename T_amount >
		explicit fn_new_item( char _dummy, const T_in_acct_id& in_acct_id, const T_new_item_index& new_item_index, const T_amount& amount ) {
			sp->in.in_acct_id = in_acct_id; // DEFAULT
			sp->in.new_item_index = new_item_index; // DEFAULT
			sp->in.amount = amount; // DEFAULT
		}
		template < typename T_in_acct_id, typename T_new_item_index, typename T_amount >
		void init( const T_in_acct_id& in_acct_id, const T_new_item_index& new_item_index, const T_amount& amount ) {
			sp->in.in_acct_id = in_acct_id; // DEFAULT
			sp->in.new_item_index = new_item_index; // DEFAULT
			sp->in.amount = amount; // DEFAULT
		}
		template < typename PacketType >
		explicit fn_new_item( const PacketType* p ) {
			init( 
				p->in_acct_id, p->new_item_index, p->amount
			);
		}
	private:
		fn_new_item() = delete;
	};

} // namespace
#pragma warning(pop)
