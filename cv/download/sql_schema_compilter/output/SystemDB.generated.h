// generated by SQL COMPILER
// time : 2018-07-12 09:57:59.232
// do not modify
// contact: icedac@gmail.com
#pragma once
#pragma warning(push)
#pragma warning(disable: 4100) // unreferenced formal parameter

namespace bb_system {

	using corn::FormatString;

	inline const char* name_A() { return "bb_system"; }
	inline const wchar_t* name_W() { return L"bb_system"; };
	inline const TCHAR* name() { return _T("bb_system"); }
	const int64_t version = 0x0000000000000020; // 32
	const int64_t minor_version = 0x01d4197b608c0d50; // 131758306792050000

	/****************************************************************************
	*
	*	stored procedure: sp_version_check
	*/
	struct sp_version_check
	{
		static const char* name_A() { return "sp_version_check"; }
		static const wchar_t* name_W() { return L"sp_version_check"; };
		static const TCHAR* name() { return _T("sp_version_check"); }

		struct sp_t {

			struct out_t {
				std::int64_t version; // bigint
				std::int64_t minor_version; // bigint

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, version, "version")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, minor_version, "minor_version")
				END_OTLA_BINDING
			} out;


			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.version, "version")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.minor_version, "minor_version")
			END_OTLA_BINDING
		}; // struct sp {

		//
		oTLA::StoredProcedure<sp_t> sp;
		oTLA::Search<sp_t::out_t> out;
	
		template < typename UPDATER >
		void open( UPDATER* u, const TCHAR* db_name = nullptr )
		{
			auto sp_name = FormatString(_T("%s.%s"), db_name ? db_name : bb_system::name(), name() ).AsString();
			sp.Open(u, sp_name.c_str());
			out.Open(u,nullptr);
		}
	};

// explicits copy structs
	/****************************************************************************
	*
	*	table: static_acct_info
	*/
	
	struct static_acct_info
	{
		static const char* name_A() { return "static_acct_info"; }
		static const wchar_t* name_W() { return L"static_acct_info"; };
		static const TCHAR* name() { return _T("static_acct_info"); };

		static std::basic_string<TCHAR> table_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_system"), name()).AsString();
		}

		struct table_t {
			std::uint32_t acct_level; // int; 
			std::uint32_t max_ap; // int; 
			std::uint32_t exp_to_lvup; // int; 
			std::uint32_t total_exp_to_lvup; // int; 

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, acct_level, "acct_level")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, max_ap, "max_ap")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, exp_to_lvup, "exp_to_lvup")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, total_exp_to_lvup, "total_exp_to_lvup")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.acct_level = from.acct_level; // CT_PRIMITIVE
				to.max_ap = from.max_ap; // CT_PRIMITIVE
				to.exp_to_lvup = from.exp_to_lvup; // CT_PRIMITIVE
				to.total_exp_to_lvup = from.total_exp_to_lvup; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.acct_level = from.acct_level; // CT_PRIMITIVE
				to.max_ap = from.max_ap; // CT_PRIMITIVE
				to.exp_to_lvup = from.exp_to_lvup; // CT_PRIMITIVE
				to.total_exp_to_lvup = from.total_exp_to_lvup; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.acct_level = from.acct_level; // CT_PRIMITIVE
				to.max_ap = from.max_ap; // CT_PRIMITIVE
				to.exp_to_lvup = from.exp_to_lvup; // CT_PRIMITIVE
				to.total_exp_to_lvup = from.total_exp_to_lvup; // CT_PRIMITIVE
			}
		};
		// where clause classes
		struct PK_by_acct_level { // PRIMARY_KEY
			std::uint32_t acct_level; // int
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, acct_level, "acct_level")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.acct_level = from.acct_level; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.acct_level = from.acct_level; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.acct_level = from.acct_level; // CT_PRIMITIVE
			}
		};
		struct PK_by_all { // PRIMARY_KEY_ALL
			std::uint32_t acct_level; // int

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, acct_level, "acct_level")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.acct_level = from.acct_level; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.acct_level = from.acct_level; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.acct_level = from.acct_level; // CT_PRIMITIVE
			}
		};

		template < typename DB >
		static oTLA::Persist<table_t> persist(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::Persist<table_t> u(db, table_name(db_name).c_str() );
			return std::move(u);
		}

		template < typename DB, typename Where >
		static oTLA::search_t<table_t, DB,Where> search(DB* db, const Where& where, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, Where> u(db, table_name(db_name).c_str(), where);
			return std::move(u);
		}

		template < typename DB >
		static oTLA::search_t<table_t, DB, oTLA::NullWhereClause> search(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, oTLA::NullWhereClause> u(db, table_name(db_name).c_str(), oTLA::NullWhereClause());
			return std::move(u);
		}
		
	};

	/****************************************************************************
	*
	*	table: static_char_info
	*/
	
	struct static_char_info
	{
		static const char* name_A() { return "static_char_info"; }
		static const wchar_t* name_W() { return L"static_char_info"; };
		static const TCHAR* name() { return _T("static_char_info"); };

		static std::basic_string<TCHAR> table_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_system"), name()).AsString();
		}

		struct table_t {
			std::uint32_t char_index; // int; 
			std::uint32_t char_level; // int; 
			std::uint32_t exp_to_lvup; // int; 
			std::uint32_t total_exp_to_lvup; // int; 
			std::uint32_t char_att; // int; 
			std::uint32_t char_def; // int; 
			std::uint32_t char_health; // int; 
			std::uint32_t char_ai; // int; 
			static const auto char_attr_train_time__max_size = 4;
			std::uint32_t char_attr_train_time[4]; // int; att,def,health,ai
			std::uint32_t max_attr_point; // int; max attr points
			std::uint32_t attr_train_gold_cost; // int; 
			std::uint32_t max_spec_point; // int; 

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_index, "char_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_level, "char_level")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, exp_to_lvup, "exp_to_lvup")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, total_exp_to_lvup, "total_exp_to_lvup")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_att, "char_att")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_def, "char_def")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_health, "char_health")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_ai, "char_ai")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_attr_train_time[0], "char_attr_train_time_0")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_attr_train_time[1], "char_attr_train_time_1")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_attr_train_time[2], "char_attr_train_time_2")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, char_attr_train_time[3], "char_attr_train_time_3")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, max_attr_point, "max_attr_point")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, attr_train_gold_cost, "attr_train_gold_cost")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, max_spec_point, "max_spec_point")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.char_index = from.char_index; // CT_PRIMITIVE
				to.char_level = from.char_level; // CT_PRIMITIVE
				to.exp_to_lvup = from.exp_to_lvup; // CT_PRIMITIVE
				to.total_exp_to_lvup = from.total_exp_to_lvup; // CT_PRIMITIVE
				to.char_att = from.char_att; // CT_PRIMITIVE
				to.char_def = from.char_def; // CT_PRIMITIVE
				to.char_health = from.char_health; // CT_PRIMITIVE
				to.char_ai = from.char_ai; // CT_PRIMITIVE
				for ( int i = 0; i < 4; ++i )
					to.char_attr_train_time[i] = from.char_attr_train_time[i]; // CT_PRIMITIVE[]
				to.max_attr_point = from.max_attr_point; // CT_PRIMITIVE
				to.attr_train_gold_cost = from.attr_train_gold_cost; // CT_PRIMITIVE
				to.max_spec_point = from.max_spec_point; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.char_index = from.char_index; // CT_PRIMITIVE
				to.char_level = from.char_level; // CT_PRIMITIVE
				to.exp_to_lvup = from.exp_to_lvup; // CT_PRIMITIVE
				to.total_exp_to_lvup = from.total_exp_to_lvup; // CT_PRIMITIVE
				to.char_att = from.char_att; // CT_PRIMITIVE
				to.char_def = from.char_def; // CT_PRIMITIVE
				to.char_health = from.char_health; // CT_PRIMITIVE
				to.char_ai = from.char_ai; // CT_PRIMITIVE
				for ( int i = 0; i < 4; ++i )
					to.char_attr_train_time[i] = from.char_attr_train_time[i]; // CT_PRIMITIVE[]
				to.max_attr_point = from.max_attr_point; // CT_PRIMITIVE
				to.attr_train_gold_cost = from.attr_train_gold_cost; // CT_PRIMITIVE
				to.max_spec_point = from.max_spec_point; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.char_index = from.char_index; // CT_PRIMITIVE
				to.char_level = from.char_level; // CT_PRIMITIVE
				to.exp_to_lvup = from.exp_to_lvup; // CT_PRIMITIVE
				to.total_exp_to_lvup = from.total_exp_to_lvup; // CT_PRIMITIVE
				to.char_att = from.char_att; // CT_PRIMITIVE
				to.char_def = from.char_def; // CT_PRIMITIVE
				to.char_health = from.char_health; // CT_PRIMITIVE
				to.char_ai = from.char_ai; // CT_PRIMITIVE
				for ( int i = 0; i < 4; ++i )
					to.char_attr_train_time[i] = from.char_attr_train_time[i]; // CT_PRIMITIVE[]
				to.max_attr_point = from.max_attr_point; // CT_PRIMITIVE
				to.attr_train_gold_cost = from.attr_train_gold_cost; // CT_PRIMITIVE
				to.max_spec_point = from.max_spec_point; // CT_PRIMITIVE
			}
		};
		// where clause classes
		struct PK_by_char_index { // PRIMARY_KEY
			std::uint32_t char_index; // int
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, char_index, "char_index")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.char_index = from.char_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.char_index = from.char_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.char_index = from.char_index; // CT_PRIMITIVE
			}
		};
		struct PK_by_char_level { // PRIMARY_KEY
			std::uint32_t char_level; // int
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, char_level, "char_level")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.char_level = from.char_level; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.char_level = from.char_level; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.char_level = from.char_level; // CT_PRIMITIVE
			}
		};
		struct PK_by_all { // PRIMARY_KEY_ALL
			std::uint32_t char_index; // int
			std::uint32_t char_level; // int

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, char_index, "char_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, char_level, "char_level")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.char_index = from.char_index; // CT_PRIMITIVE
				to.char_level = from.char_level; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.char_index = from.char_index; // CT_PRIMITIVE
				to.char_level = from.char_level; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.char_index = from.char_index; // CT_PRIMITIVE
				to.char_level = from.char_level; // CT_PRIMITIVE
			}
		};

		template < typename DB >
		static oTLA::Persist<table_t> persist(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::Persist<table_t> u(db, table_name(db_name).c_str() );
			return std::move(u);
		}

		template < typename DB, typename Where >
		static oTLA::search_t<table_t, DB,Where> search(DB* db, const Where& where, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, Where> u(db, table_name(db_name).c_str(), where);
			return std::move(u);
		}

		template < typename DB >
		static oTLA::search_t<table_t, DB, oTLA::NullWhereClause> search(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, oTLA::NullWhereClause> u(db, table_name(db_name).c_str(), oTLA::NullWhereClause());
			return std::move(u);
		}
		
	};

	/****************************************************************************
	*
	*	table: static_monster
	*/
	
	struct static_monster
	{
		static const char* name_A() { return "static_monster"; }
		static const wchar_t* name_W() { return L"static_monster"; };
		static const TCHAR* name() { return _T("static_monster"); };

		static std::basic_string<TCHAR> table_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_system"), name()).AsString();
		}

		struct table_t {
			std::uint32_t monster_index; // int; 
			corn::TFixedStringA<50> monster_code; // varchar; 
			corn::TFixedStringA<50> monster_name; // varchar; 
			corn::TFixedStringA<50> reward_code; // varchar; 
			std::uint32_t monster_grade; // int; 몬스터 등급
			std::uint32_t monster_gold_min; // int; 
			std::uint32_t monster_gold_max; // int; 
			std::uint32_t monster_exp; // int; 
			std::uint32_t Monster_Lv; // int; 
			corn::TFixedStringA<50> Attack_Type; // varchar; 
			std::uint32_t Item_MinDam; // int; 
			std::uint32_t Item_MaxDam; // int; 
			std::uint32_t Item_Att; // int; 
			std::uint32_t Item_Def; // int; 
			std::uint32_t Item_Health; // int; 
			float Dam_Slash; // float; 
			float Dam_Crash; // float; 
			float Dam_Pierce; // float; 
			std::uint32_t Item_Pen; // int; 
			float Item_PenPer; // float; 
			float Item_CriPer; // float; 
			float Item_CriRat; // float; 
			std::uint32_t Item_TrueDam; // int; 
			corn::TFixedStringA<50> TagRule; // varchar; 

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, monster_index, "monster_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, monster_code, "monster_code")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, monster_name, "monster_name")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, reward_code, "reward_code")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, monster_grade, "monster_grade")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, monster_gold_min, "monster_gold_min")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, monster_gold_max, "monster_gold_max")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, monster_exp, "monster_exp")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Monster_Lv, "Monster_Lv")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Attack_Type, "Attack_Type")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Item_MinDam, "Item_MinDam")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Item_MaxDam, "Item_MaxDam")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Item_Att, "Item_Att")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Item_Def, "Item_Def")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Item_Health, "Item_Health")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Dam_Slash, "Dam_Slash")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Dam_Crash, "Dam_Crash")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Dam_Pierce, "Dam_Pierce")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Item_Pen, "Item_Pen")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Item_PenPer, "Item_PenPer")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Item_CriPer, "Item_CriPer")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Item_CriRat, "Item_CriRat")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, Item_TrueDam, "Item_TrueDam")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, TagRule, "TagRule")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.monster_index = from.monster_index; // CT_PRIMITIVE
				to.monster_code = from.monster_code; // CT_STRING
				to.monster_name = from.monster_name; // CT_STRING
				to.reward_code = from.reward_code; // CT_STRING
				to.monster_grade = from.monster_grade; // CT_PRIMITIVE
				to.monster_gold_min = from.monster_gold_min; // CT_PRIMITIVE
				to.monster_gold_max = from.monster_gold_max; // CT_PRIMITIVE
				to.monster_exp = from.monster_exp; // CT_PRIMITIVE
				to.Monster_Lv = from.Monster_Lv; // CT_PRIMITIVE
				to.Attack_Type = from.Attack_Type; // CT_STRING
				to.Item_MinDam = from.Item_MinDam; // CT_PRIMITIVE
				to.Item_MaxDam = from.Item_MaxDam; // CT_PRIMITIVE
				to.Item_Att = from.Item_Att; // CT_PRIMITIVE
				to.Item_Def = from.Item_Def; // CT_PRIMITIVE
				to.Item_Health = from.Item_Health; // CT_PRIMITIVE
				to.Dam_Slash = from.Dam_Slash; // CT_PRIMITIVE
				to.Dam_Crash = from.Dam_Crash; // CT_PRIMITIVE
				to.Dam_Pierce = from.Dam_Pierce; // CT_PRIMITIVE
				to.Item_Pen = from.Item_Pen; // CT_PRIMITIVE
				to.Item_PenPer = from.Item_PenPer; // CT_PRIMITIVE
				to.Item_CriPer = from.Item_CriPer; // CT_PRIMITIVE
				to.Item_CriRat = from.Item_CriRat; // CT_PRIMITIVE
				to.Item_TrueDam = from.Item_TrueDam; // CT_PRIMITIVE
				to.TagRule = from.TagRule; // CT_STRING
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.monster_index = from.monster_index; // CT_PRIMITIVE
				to.monster_code = from.monster_code.c_str(); // CT_STRING
				to.monster_name = from.monster_name.c_str(); // CT_STRING
				to.reward_code = from.reward_code.c_str(); // CT_STRING
				to.monster_grade = from.monster_grade; // CT_PRIMITIVE
				to.monster_gold_min = from.monster_gold_min; // CT_PRIMITIVE
				to.monster_gold_max = from.monster_gold_max; // CT_PRIMITIVE
				to.monster_exp = from.monster_exp; // CT_PRIMITIVE
				to.Monster_Lv = from.Monster_Lv; // CT_PRIMITIVE
				to.Attack_Type = from.Attack_Type.c_str(); // CT_STRING
				to.Item_MinDam = from.Item_MinDam; // CT_PRIMITIVE
				to.Item_MaxDam = from.Item_MaxDam; // CT_PRIMITIVE
				to.Item_Att = from.Item_Att; // CT_PRIMITIVE
				to.Item_Def = from.Item_Def; // CT_PRIMITIVE
				to.Item_Health = from.Item_Health; // CT_PRIMITIVE
				to.Dam_Slash = from.Dam_Slash; // CT_PRIMITIVE
				to.Dam_Crash = from.Dam_Crash; // CT_PRIMITIVE
				to.Dam_Pierce = from.Dam_Pierce; // CT_PRIMITIVE
				to.Item_Pen = from.Item_Pen; // CT_PRIMITIVE
				to.Item_PenPer = from.Item_PenPer; // CT_PRIMITIVE
				to.Item_CriPer = from.Item_CriPer; // CT_PRIMITIVE
				to.Item_CriRat = from.Item_CriRat; // CT_PRIMITIVE
				to.Item_TrueDam = from.Item_TrueDam; // CT_PRIMITIVE
				to.TagRule = from.TagRule.c_str(); // CT_STRING
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.monster_index = from.monster_index; // CT_PRIMITIVE
				to.monster_code = from.monster_code.c_str(); // CT_STRING
				to.monster_name = from.monster_name.c_str(); // CT_STRING
				to.reward_code = from.reward_code.c_str(); // CT_STRING
				to.monster_grade = from.monster_grade; // CT_PRIMITIVE
				to.monster_gold_min = from.monster_gold_min; // CT_PRIMITIVE
				to.monster_gold_max = from.monster_gold_max; // CT_PRIMITIVE
				to.monster_exp = from.monster_exp; // CT_PRIMITIVE
				to.Monster_Lv = from.Monster_Lv; // CT_PRIMITIVE
				to.Attack_Type = from.Attack_Type.c_str(); // CT_STRING
				to.Item_MinDam = from.Item_MinDam; // CT_PRIMITIVE
				to.Item_MaxDam = from.Item_MaxDam; // CT_PRIMITIVE
				to.Item_Att = from.Item_Att; // CT_PRIMITIVE
				to.Item_Def = from.Item_Def; // CT_PRIMITIVE
				to.Item_Health = from.Item_Health; // CT_PRIMITIVE
				to.Dam_Slash = from.Dam_Slash; // CT_PRIMITIVE
				to.Dam_Crash = from.Dam_Crash; // CT_PRIMITIVE
				to.Dam_Pierce = from.Dam_Pierce; // CT_PRIMITIVE
				to.Item_Pen = from.Item_Pen; // CT_PRIMITIVE
				to.Item_PenPer = from.Item_PenPer; // CT_PRIMITIVE
				to.Item_CriPer = from.Item_CriPer; // CT_PRIMITIVE
				to.Item_CriRat = from.Item_CriRat; // CT_PRIMITIVE
				to.Item_TrueDam = from.Item_TrueDam; // CT_PRIMITIVE
				to.TagRule = from.TagRule.c_str(); // CT_STRING
			}
		};
		// where clause classes
		struct PK_by_monster_index { // PRIMARY_KEY
			std::uint32_t monster_index; // int
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, monster_index, "monster_index")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.monster_index = from.monster_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.monster_index = from.monster_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.monster_index = from.monster_index; // CT_PRIMITIVE
			}
		};
		struct K_by_monster_code { // KEY
			corn::TFixedStringA<50> monster_code; // varchar
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, monster_code, "monster_code")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.monster_code = from.monster_code; // CT_STRING
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.monster_code = from.monster_code.c_str(); // CT_STRING
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.monster_code = from.monster_code.c_str(); // CT_STRING
			}
		};
		struct PK_by_all { // PRIMARY_KEY_ALL
			std::uint32_t monster_index; // int

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, monster_index, "monster_index")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.monster_index = from.monster_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.monster_index = from.monster_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.monster_index = from.monster_index; // CT_PRIMITIVE
			}
		};

		template < typename DB >
		static oTLA::Persist<table_t> persist(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::Persist<table_t> u(db, table_name(db_name).c_str() );
			return std::move(u);
		}

		template < typename DB, typename Where >
		static oTLA::search_t<table_t, DB,Where> search(DB* db, const Where& where, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, Where> u(db, table_name(db_name).c_str(), where);
			return std::move(u);
		}

		template < typename DB >
		static oTLA::search_t<table_t, DB, oTLA::NullWhereClause> search(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, oTLA::NullWhereClause> u(db, table_name(db_name).c_str(), oTLA::NullWhereClause());
			return std::move(u);
		}
		
	};

	/****************************************************************************
	*
	*	table: static_mission
	*/
	
	struct static_mission
	{
		static const char* name_A() { return "static_mission"; }
		static const wchar_t* name_W() { return L"static_mission"; };
		static const TCHAR* name() { return _T("static_mission"); };

		static std::basic_string<TCHAR> table_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_system"), name()).AsString();
		}

		struct table_t {
			std::uint32_t mission_index; // int; 
			corn::TFixedStringA<50> mission_code; // varchar; 
			corn::TFixedStringA<50> mission_name; // varchar; 
			std::uint32_t ap_cost; // int; ap 소모
			std::uint32_t mission_group; // int; 미션 그룹
			corn::TFixedStringA<50> boss_monster_code; // varchar; 
			std::uint32_t opt_monster_count; // int; 잡몹 숫자
			static const auto opt_monster_code__max_size = 10;
			corn::TFixedStringA<50> opt_monster_code[10]; // varchar; 잡몹 코드
			corn::TFixedStringA<50> reward_code_if_cleard_1st; // varchar; 
			static const auto drop_item_index__max_size = 5;
			std::uint32_t drop_item_index[5]; // int; 추가 데이터: 드랍 아이템 Index 리스트

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, mission_index, "mission_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, mission_code, "mission_code")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, mission_name, "mission_name")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, ap_cost, "ap_cost")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, mission_group, "mission_group")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, boss_monster_code, "boss_monster_code")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, opt_monster_count, "opt_monster_count")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, opt_monster_code[0], "opt_monster_code_0")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, opt_monster_code[1], "opt_monster_code_1")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, opt_monster_code[2], "opt_monster_code_2")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, opt_monster_code[3], "opt_monster_code_3")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, opt_monster_code[4], "opt_monster_code_4")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, opt_monster_code[5], "opt_monster_code_5")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, opt_monster_code[6], "opt_monster_code_6")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, opt_monster_code[7], "opt_monster_code_7")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, opt_monster_code[8], "opt_monster_code_8")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, opt_monster_code[9], "opt_monster_code_9")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, reward_code_if_cleard_1st, "reward_code_if_cleard_1st")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, drop_item_index[0], "drop_item_index_0")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, drop_item_index[1], "drop_item_index_1")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, drop_item_index[2], "drop_item_index_2")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, drop_item_index[3], "drop_item_index_3")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, drop_item_index[4], "drop_item_index_4")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.mission_index = from.mission_index; // CT_PRIMITIVE
				to.mission_code = from.mission_code; // CT_STRING
				to.mission_name = from.mission_name; // CT_STRING
				to.ap_cost = from.ap_cost; // CT_PRIMITIVE
				to.mission_group = from.mission_group; // CT_PRIMITIVE
				to.boss_monster_code = from.boss_monster_code; // CT_STRING
				to.opt_monster_count = from.opt_monster_count; // CT_PRIMITIVE
				for ( int i = 0; i < 10; ++i )
					to.opt_monster_code[i] = from.opt_monster_code[i]; // CT_STRING[]
				to.reward_code_if_cleard_1st = from.reward_code_if_cleard_1st; // CT_STRING
				for ( int i = 0; i < 5; ++i )
					to.drop_item_index[i] = from.drop_item_index[i]; // CT_PRIMITIVE[]
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.mission_index = from.mission_index; // CT_PRIMITIVE
				to.mission_code = from.mission_code.c_str(); // CT_STRING
				to.mission_name = from.mission_name.c_str(); // CT_STRING
				to.ap_cost = from.ap_cost; // CT_PRIMITIVE
				to.mission_group = from.mission_group; // CT_PRIMITIVE
				to.boss_monster_code = from.boss_monster_code.c_str(); // CT_STRING
				to.opt_monster_count = from.opt_monster_count; // CT_PRIMITIVE
				for ( int i = 0; i < 10; ++i )
					to.opt_monster_code[i] = from.opt_monster_code[i].c_str(); // CT_STRING[]
				to.reward_code_if_cleard_1st = from.reward_code_if_cleard_1st.c_str(); // CT_STRING
				for ( int i = 0; i < 5; ++i )
					to.drop_item_index[i] = from.drop_item_index[i]; // CT_PRIMITIVE[]
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.mission_index = from.mission_index; // CT_PRIMITIVE
				to.mission_code = from.mission_code.c_str(); // CT_STRING
				to.mission_name = from.mission_name.c_str(); // CT_STRING
				to.ap_cost = from.ap_cost; // CT_PRIMITIVE
				to.mission_group = from.mission_group; // CT_PRIMITIVE
				to.boss_monster_code = from.boss_monster_code.c_str(); // CT_STRING
				to.opt_monster_count = from.opt_monster_count; // CT_PRIMITIVE
				for ( int i = 0; i < 10; ++i )
					to.opt_monster_code[i] = from.opt_monster_code[i].c_str(); // CT_STRING[]
				to.reward_code_if_cleard_1st = from.reward_code_if_cleard_1st.c_str(); // CT_STRING
				for ( int i = 0; i < 5; ++i )
					to.drop_item_index[i] = from.drop_item_index[i]; // CT_PRIMITIVE[]
			}
		};
		// where clause classes
		struct PK_by_mission_index { // PRIMARY_KEY
			std::uint32_t mission_index; // int
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, mission_index, "mission_index")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.mission_index = from.mission_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.mission_index = from.mission_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.mission_index = from.mission_index; // CT_PRIMITIVE
			}
		};
		struct K_by_mission_code { // KEY
			corn::TFixedStringA<50> mission_code; // varchar
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, mission_code, "mission_code")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.mission_code = from.mission_code; // CT_STRING
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.mission_code = from.mission_code.c_str(); // CT_STRING
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.mission_code = from.mission_code.c_str(); // CT_STRING
			}
		};
		struct K_by_mission_group { // KEY
			std::uint32_t mission_group; // int
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, mission_group, "mission_group")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.mission_group = from.mission_group; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.mission_group = from.mission_group; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.mission_group = from.mission_group; // CT_PRIMITIVE
			}
		};
		struct PK_by_all { // PRIMARY_KEY_ALL
			std::uint32_t mission_index; // int

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, mission_index, "mission_index")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.mission_index = from.mission_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.mission_index = from.mission_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.mission_index = from.mission_index; // CT_PRIMITIVE
			}
		};

		template < typename DB >
		static oTLA::Persist<table_t> persist(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::Persist<table_t> u(db, table_name(db_name).c_str() );
			return std::move(u);
		}

		template < typename DB, typename Where >
		static oTLA::search_t<table_t, DB,Where> search(DB* db, const Where& where, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, Where> u(db, table_name(db_name).c_str(), where);
			return std::move(u);
		}

		template < typename DB >
		static oTLA::search_t<table_t, DB, oTLA::NullWhereClause> search(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, oTLA::NullWhereClause> u(db, table_name(db_name).c_str(), oTLA::NullWhereClause());
			return std::move(u);
		}
		
	};

	/****************************************************************************
	*
	*	table: static_item
	*/
	
	struct static_item
	{
		static const char* name_A() { return "static_item"; }
		static const wchar_t* name_W() { return L"static_item"; };
		static const TCHAR* name() { return _T("static_item"); };

		static std::basic_string<TCHAR> table_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_system"), name()).AsString();
		}

		struct table_t {
			std::uint32_t item_index; // int; 
			corn::TFixedStringA<50> code; // varchar; 아이템 코드
			corn::TFixedStringA<50> name; // varchar; 아이템 이름
			std::uint32_t item_tier; // int; 아이템 아레나 티어
			std::uint32_t grade; // int; 아이템 등급. 1:Normal 2:Uncommon ... 5: legend
			std::uint32_t max_stack; // int; 아이템 최대 스택 수
			std::uint32_t max_level; // int; 최대 레벨
			corn::TFixedStringA<50> item_desc; // varchar; 아이템 설명
			std::uint32_t slot; // int; 아이템 장착 부위 0:skin ... 1:weapon, 88: skill_dummy 99: skill, 255:other
			std::uint32_t evolvable_item_index; // int;  진화 가능하면 진화 가능한 아이템 Index, 0이면 불가능
			std::uint32_t equippable_char_index; // int;  장착 가능한 캐릭터 인덱스, 0이면 아무나 
			std::uint32_t base_sell_price; // int; 
			corn::TFixedStringA<50> reward_code_on_use; // varchar; 
			std::uint32_t expire_in_hours; // int; 0; 무제한, 주의: stackable 아이템에 기한제한을 넣으면 좇된다

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, item_index, "item_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, code, "code")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, name, "name")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, item_tier, "item_tier")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, grade, "grade")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, max_stack, "max_stack")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, max_level, "max_level")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, item_desc, "item_desc")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, slot, "slot")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, evolvable_item_index, "evolvable_item_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, equippable_char_index, "equippable_char_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, base_sell_price, "base_sell_price")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, reward_code_on_use, "reward_code_on_use")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expire_in_hours, "expire_in_hours")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.item_index = from.item_index; // CT_PRIMITIVE
				to.code = from.code; // CT_STRING
				to.name = from.name; // CT_STRING
				to.item_tier = from.item_tier; // CT_PRIMITIVE
				to.grade = from.grade; // CT_PRIMITIVE
				to.max_stack = from.max_stack; // CT_PRIMITIVE
				to.max_level = from.max_level; // CT_PRIMITIVE
				to.item_desc = from.item_desc; // CT_STRING
				to.slot = from.slot; // CT_PRIMITIVE
				to.evolvable_item_index = from.evolvable_item_index; // CT_PRIMITIVE
				to.equippable_char_index = from.equippable_char_index; // CT_PRIMITIVE
				to.base_sell_price = from.base_sell_price; // CT_PRIMITIVE
				to.reward_code_on_use = from.reward_code_on_use; // CT_STRING
				to.expire_in_hours = from.expire_in_hours; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.item_index = from.item_index; // CT_PRIMITIVE
				to.code = from.code.c_str(); // CT_STRING
				to.name = from.name.c_str(); // CT_STRING
				to.item_tier = from.item_tier; // CT_PRIMITIVE
				to.grade = from.grade; // CT_PRIMITIVE
				to.max_stack = from.max_stack; // CT_PRIMITIVE
				to.max_level = from.max_level; // CT_PRIMITIVE
				to.item_desc = from.item_desc.c_str(); // CT_STRING
				to.slot = from.slot; // CT_PRIMITIVE
				to.evolvable_item_index = from.evolvable_item_index; // CT_PRIMITIVE
				to.equippable_char_index = from.equippable_char_index; // CT_PRIMITIVE
				to.base_sell_price = from.base_sell_price; // CT_PRIMITIVE
				to.reward_code_on_use = from.reward_code_on_use.c_str(); // CT_STRING
				to.expire_in_hours = from.expire_in_hours; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.item_index = from.item_index; // CT_PRIMITIVE
				to.code = from.code.c_str(); // CT_STRING
				to.name = from.name.c_str(); // CT_STRING
				to.item_tier = from.item_tier; // CT_PRIMITIVE
				to.grade = from.grade; // CT_PRIMITIVE
				to.max_stack = from.max_stack; // CT_PRIMITIVE
				to.max_level = from.max_level; // CT_PRIMITIVE
				to.item_desc = from.item_desc.c_str(); // CT_STRING
				to.slot = from.slot; // CT_PRIMITIVE
				to.evolvable_item_index = from.evolvable_item_index; // CT_PRIMITIVE
				to.equippable_char_index = from.equippable_char_index; // CT_PRIMITIVE
				to.base_sell_price = from.base_sell_price; // CT_PRIMITIVE
				to.reward_code_on_use = from.reward_code_on_use.c_str(); // CT_STRING
				to.expire_in_hours = from.expire_in_hours; // CT_PRIMITIVE
			}
		};
		// where clause classes
		struct PK_by_item_index { // PRIMARY_KEY
			std::uint32_t item_index; // int
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, item_index, "item_index")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.item_index = from.item_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.item_index = from.item_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.item_index = from.item_index; // CT_PRIMITIVE
			}
		};
		struct K_by_code { // KEY
			corn::TFixedStringA<50> code; // varchar
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, code, "code")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.code = from.code; // CT_STRING
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.code = from.code.c_str(); // CT_STRING
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.code = from.code.c_str(); // CT_STRING
			}
		};
		struct PK_by_all { // PRIMARY_KEY_ALL
			std::uint32_t item_index; // int

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, item_index, "item_index")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.item_index = from.item_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.item_index = from.item_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.item_index = from.item_index; // CT_PRIMITIVE
			}
		};

		template < typename DB >
		static oTLA::Persist<table_t> persist(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::Persist<table_t> u(db, table_name(db_name).c_str() );
			return std::move(u);
		}

		template < typename DB, typename Where >
		static oTLA::search_t<table_t, DB,Where> search(DB* db, const Where& where, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, Where> u(db, table_name(db_name).c_str(), where);
			return std::move(u);
		}

		template < typename DB >
		static oTLA::search_t<table_t, DB, oTLA::NullWhereClause> search(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, oTLA::NullWhereClause> u(db, table_name(db_name).c_str(), oTLA::NullWhereClause());
			return std::move(u);
		}
		
	};

	/****************************************************************************
	*
	*	table: static_reward
	*/
	
	struct static_reward
	{
		static const char* name_A() { return "static_reward"; }
		static const wchar_t* name_W() { return L"static_reward"; };
		static const TCHAR* name() { return _T("static_reward"); };

		static std::basic_string<TCHAR> table_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_system"), name()).AsString();
		}

		struct table_t {
			std::uint32_t reward_index; // int; 
			corn::TFixedStringA<50> reward_code; // varchar; 
			corn::TFixedStringA<50> expr_gold; // varchar; 
			corn::TFixedStringA<50> expr_ruby; // varchar; 
			corn::TFixedStringA<50> expr_honor; // varchar; 
			corn::TFixedStringA<50> expr_exp; // varchar; 
			corn::TFixedStringA<50> expr_ap; // varchar; 
			static const auto expr_item__max_size = 20;
			corn::TFixedStringA<50> expr_item[20]; // varchar; 

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, reward_index, "reward_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, reward_code, "reward_code")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_gold, "expr_gold")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_ruby, "expr_ruby")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_honor, "expr_honor")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_exp, "expr_exp")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_ap, "expr_ap")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[0], "expr_item_0")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[1], "expr_item_1")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[2], "expr_item_2")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[3], "expr_item_3")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[4], "expr_item_4")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[5], "expr_item_5")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[6], "expr_item_6")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[7], "expr_item_7")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[8], "expr_item_8")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[9], "expr_item_9")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[10], "expr_item_10")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[11], "expr_item_11")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[12], "expr_item_12")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[13], "expr_item_13")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[14], "expr_item_14")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[15], "expr_item_15")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[16], "expr_item_16")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[17], "expr_item_17")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[18], "expr_item_18")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::FROM_DB, expr_item[19], "expr_item_19")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.reward_index = from.reward_index; // CT_PRIMITIVE
				to.reward_code = from.reward_code; // CT_STRING
				to.expr_gold = from.expr_gold; // CT_STRING
				to.expr_ruby = from.expr_ruby; // CT_STRING
				to.expr_honor = from.expr_honor; // CT_STRING
				to.expr_exp = from.expr_exp; // CT_STRING
				to.expr_ap = from.expr_ap; // CT_STRING
				for ( int i = 0; i < 20; ++i )
					to.expr_item[i] = from.expr_item[i]; // CT_STRING[]
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.reward_index = from.reward_index; // CT_PRIMITIVE
				to.reward_code = from.reward_code.c_str(); // CT_STRING
				to.expr_gold = from.expr_gold.c_str(); // CT_STRING
				to.expr_ruby = from.expr_ruby.c_str(); // CT_STRING
				to.expr_honor = from.expr_honor.c_str(); // CT_STRING
				to.expr_exp = from.expr_exp.c_str(); // CT_STRING
				to.expr_ap = from.expr_ap.c_str(); // CT_STRING
				for ( int i = 0; i < 20; ++i )
					to.expr_item[i] = from.expr_item[i].c_str(); // CT_STRING[]
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.reward_index = from.reward_index; // CT_PRIMITIVE
				to.reward_code = from.reward_code.c_str(); // CT_STRING
				to.expr_gold = from.expr_gold.c_str(); // CT_STRING
				to.expr_ruby = from.expr_ruby.c_str(); // CT_STRING
				to.expr_honor = from.expr_honor.c_str(); // CT_STRING
				to.expr_exp = from.expr_exp.c_str(); // CT_STRING
				to.expr_ap = from.expr_ap.c_str(); // CT_STRING
				for ( int i = 0; i < 20; ++i )
					to.expr_item[i] = from.expr_item[i].c_str(); // CT_STRING[]
			}
		};
		// where clause classes
		struct PK_by_reward_index { // PRIMARY_KEY
			std::uint32_t reward_index; // int
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, reward_index, "reward_index")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.reward_index = from.reward_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.reward_index = from.reward_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.reward_index = from.reward_index; // CT_PRIMITIVE
			}
		};
		struct K_by_reward_code { // KEY
			corn::TFixedStringA<50> reward_code; // varchar
			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, reward_code, "reward_code")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.reward_code = from.reward_code; // CT_STRING
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.reward_code = from.reward_code.c_str(); // CT_STRING
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.reward_code = from.reward_code.c_str(); // CT_STRING
			}
		};
		struct PK_by_all { // PRIMARY_KEY_ALL
			std::uint32_t reward_index; // int

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::TO_DB | oTLA::UNIQUE_FIELD, reward_index, "reward_index")
			END_OTLA_BINDING

			template < typename U, typename V > // packet to packet
			static void copy(const U& from, V& to) {
				to.reward_index = from.reward_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // db to packet
			static void copy_from( const DB& from, T& to ) {
				to.reward_index = from.reward_index; // CT_PRIMITIVE
			}
			template < typename DB, typename T > // packet to db
			static void copy_to( const T& from, DB& to ) {
				to.reward_index = from.reward_index; // CT_PRIMITIVE
			}
		};

		template < typename DB >
		static oTLA::Persist<table_t> persist(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::Persist<table_t> u(db, table_name(db_name).c_str() );
			return std::move(u);
		}

		template < typename DB, typename Where >
		static oTLA::search_t<table_t, DB,Where> search(DB* db, const Where& where, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, Where> u(db, table_name(db_name).c_str(), where);
			return std::move(u);
		}

		template < typename DB >
		static oTLA::search_t<table_t, DB, oTLA::NullWhereClause> search(DB* db, const TCHAR* db_name = nullptr)
		{
			oTLA::search_t<table_t, DB, oTLA::NullWhereClause> u(db, table_name(db_name).c_str(), oTLA::NullWhereClause());
			return std::move(u);
		}
		
	};

	/****************************************************************************
	*
	*	stored procedure: sp_import_char_info
	*/
	struct sp_import_char_info
	{
		static const char* name_A() { return "sp_import_char_info"; }
		static const wchar_t* name_W() { return L"sp_import_char_info"; };
		static const TCHAR* name() { return _T("sp_import_char_info"); };

		static std::basic_string<TCHAR> sp_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_system"), name()).AsString();
		}

		struct sp_t {
			struct {
				std::uint32_t start_char_index; // int
				std::uint32_t start_char_level; // int

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.start_char_index = from.start_char_index; // CT_PRIMITIVE
					to.start_char_level = from.start_char_level; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.start_char_index = from.start_char_index; // CT_PRIMITIVE
					to.start_char_level = from.start_char_level; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.start_char_index = from.start_char_index; // CT_PRIMITIVE
					to.start_char_level = from.start_char_level; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("start_char_index") << _T(":") << start_char_index;
					ss << _T(" in.") << _T("start_char_level") << _T(":") << start_char_level;
					return ss.str();
				}
			} in;

			struct out_t {
				std::uint32_t result; // int

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, result, "result")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("result") << _T(":") << result;
					return ss.str();
				}
			} out;

			struct result_set_t {
				std::uint32_t char_index; // int
				std::uint32_t char_level; // int
				std::uint32_t exp_to_lvup; // int
				std::uint32_t total_exp_to_lvup; // int
				std::uint32_t char_att; // int
				std::uint32_t char_def; // int
				std::uint32_t char_health; // int
				std::uint32_t char_ai; // int
				static const auto char_attr_train_time__max_size = 4;
				std::uint32_t char_attr_train_time[4]; // int
				std::uint32_t max_attr_point; // int
				std::uint32_t attr_train_gold_cost; // int
				std::uint32_t max_spec_point; // int

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, char_index, "char_index")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, char_level, "char_level")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, exp_to_lvup, "exp_to_lvup")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, total_exp_to_lvup, "total_exp_to_lvup")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, char_att, "char_att")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, char_def, "char_def")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, char_health, "char_health")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, char_ai, "char_ai")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, char_attr_train_time[0], "char_attr_train_time_0")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, char_attr_train_time[1], "char_attr_train_time_1")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, char_attr_train_time[2], "char_attr_train_time_2")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, char_attr_train_time[3], "char_attr_train_time_3")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, max_attr_point, "max_attr_point")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, attr_train_gold_cost, "attr_train_gold_cost")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, max_spec_point, "max_spec_point")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.char_index = from.char_index; // CT_PRIMITIVE
					to.char_level = from.char_level; // CT_PRIMITIVE
					to.exp_to_lvup = from.exp_to_lvup; // CT_PRIMITIVE
					to.total_exp_to_lvup = from.total_exp_to_lvup; // CT_PRIMITIVE
					to.char_att = from.char_att; // CT_PRIMITIVE
					to.char_def = from.char_def; // CT_PRIMITIVE
					to.char_health = from.char_health; // CT_PRIMITIVE
					to.char_ai = from.char_ai; // CT_PRIMITIVE
					for ( int i = 0; i < 4; ++i )
						to.char_attr_train_time[i] = from.char_attr_train_time[i]; // CT_PRIMITIVE[]
					to.max_attr_point = from.max_attr_point; // CT_PRIMITIVE
					to.attr_train_gold_cost = from.attr_train_gold_cost; // CT_PRIMITIVE
					to.max_spec_point = from.max_spec_point; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.char_index = from.char_index; // CT_PRIMITIVE
					to.char_level = from.char_level; // CT_PRIMITIVE
					to.exp_to_lvup = from.exp_to_lvup; // CT_PRIMITIVE
					to.total_exp_to_lvup = from.total_exp_to_lvup; // CT_PRIMITIVE
					to.char_att = from.char_att; // CT_PRIMITIVE
					to.char_def = from.char_def; // CT_PRIMITIVE
					to.char_health = from.char_health; // CT_PRIMITIVE
					to.char_ai = from.char_ai; // CT_PRIMITIVE
					for ( int i = 0; i < 4; ++i )
						to.char_attr_train_time[i] = from.char_attr_train_time[i]; // CT_PRIMITIVE[]
					to.max_attr_point = from.max_attr_point; // CT_PRIMITIVE
					to.attr_train_gold_cost = from.attr_train_gold_cost; // CT_PRIMITIVE
					to.max_spec_point = from.max_spec_point; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.char_index = from.char_index; // CT_PRIMITIVE
					to.char_level = from.char_level; // CT_PRIMITIVE
					to.exp_to_lvup = from.exp_to_lvup; // CT_PRIMITIVE
					to.total_exp_to_lvup = from.total_exp_to_lvup; // CT_PRIMITIVE
					to.char_att = from.char_att; // CT_PRIMITIVE
					to.char_def = from.char_def; // CT_PRIMITIVE
					to.char_health = from.char_health; // CT_PRIMITIVE
					to.char_ai = from.char_ai; // CT_PRIMITIVE
					for ( int i = 0; i < 4; ++i )
						to.char_attr_train_time[i] = from.char_attr_train_time[i]; // CT_PRIMITIVE[]
					to.max_attr_point = from.max_attr_point; // CT_PRIMITIVE
					to.attr_train_gold_cost = from.attr_train_gold_cost; // CT_PRIMITIVE
					to.max_spec_point = from.max_spec_point; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("char_index") << _T(":") << char_index;
					ss << _T(" in.") << _T("char_level") << _T(":") << char_level;
					ss << _T(" in.") << _T("exp_to_lvup") << _T(":") << exp_to_lvup;
					ss << _T(" in.") << _T("total_exp_to_lvup") << _T(":") << total_exp_to_lvup;
					ss << _T(" in.") << _T("char_att") << _T(":") << char_att;
					ss << _T(" in.") << _T("char_def") << _T(":") << char_def;
					ss << _T(" in.") << _T("char_health") << _T(":") << char_health;
					ss << _T(" in.") << _T("char_ai") << _T(":") << char_ai;
					ss << _T(" in.") << _T("char_attr_train_time[0]") << _T(":") << char_attr_train_time[0];
					ss << _T(" in.") << _T("char_attr_train_time[1]") << _T(":") << char_attr_train_time[1];
					ss << _T(" in.") << _T("char_attr_train_time[2]") << _T(":") << char_attr_train_time[2];
					ss << _T(" in.") << _T("char_attr_train_time[3]") << _T(":") << char_attr_train_time[3];
					ss << _T(" in.") << _T("max_attr_point") << _T(":") << max_attr_point;
					ss << _T(" in.") << _T("attr_train_gold_cost") << _T(":") << attr_train_gold_cost;
					ss << _T(" in.") << _T("max_spec_point") << _T(":") << max_spec_point;
					return ss.str();
				}
			};

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.start_char_index, "start_char_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.start_char_level, "start_char_level")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.result, "result")
			END_OTLA_BINDING
		}; // struct sp {

		//
		oTLA::StoredProcedure<sp_t> sp;
		oTLA::Search<sp_t::out_t> out;
		oTLA::Search<sp_t::result_set_t> result;
		oTLA::Search<sp_t::result_set_t> result_end;

		struct result_iterator {
			oTLA::Search<sp_t::result_set_t>* s_;
			result_iterator(oTLA::Search<sp_t::result_set_t>* s) : s_(s) {}			
			oTLA::Search<sp_t::result_set_t>::reference operator*() const { return *(*s_); }
			oTLA::Search<sp_t::result_set_t>::pointer operator->() const { return (*s_).operator->(); }
			bool operator!= (const result_iterator & rhs) const { return (*s_) != (*rhs.s_); }
			result_iterator& operator++() { ++(*s_); return *this; }
		};
		result_iterator begin() {
			return result_iterator(&result);
		}
		result_iterator end() {
			return result_iterator(&result_end);
		}
		int size() const {
			return result.Get_Row_Processed_Count();
		}
		
		template < typename UPDATER >
		void open( UPDATER* u, const TCHAR* db_name = nullptr )
		{
			result.SetExternalResultStream(sp.Get_Result_Stream());
			sp.Open(u, sp_name(db_name).c_str(), result);
			out.Open(u,nullptr);
		}
		template < typename T_start_char_index, typename T_start_char_level >
		explicit sp_import_char_info( char _dummy, const T_start_char_index& start_char_index, const T_start_char_level& start_char_level ) {
			sp->in.start_char_index = start_char_index; // DEFAULT
			sp->in.start_char_level = start_char_level; // DEFAULT
		}
		template < typename T_start_char_index, typename T_start_char_level >
		void init( const T_start_char_index& start_char_index, const T_start_char_level& start_char_level ) {
			sp->in.start_char_index = start_char_index; // DEFAULT
			sp->in.start_char_level = start_char_level; // DEFAULT
		}
		template < typename PacketType >
		explicit sp_import_char_info( const PacketType* p ) {
			init( 
				p->start_char_index, p->start_char_level
			);
		}
	private:
		sp_import_char_info() = delete;
	};
	/****************************************************************************
	*
	*	stored procedure: sp_import_monster
	*/
	struct sp_import_monster
	{
		static const char* name_A() { return "sp_import_monster"; }
		static const wchar_t* name_W() { return L"sp_import_monster"; };
		static const TCHAR* name() { return _T("sp_import_monster"); };

		static std::basic_string<TCHAR> sp_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_system"), name()).AsString();
		}

		struct sp_t {
			struct {
				std::uint32_t start_monster_index; // int

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.start_monster_index = from.start_monster_index; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.start_monster_index = from.start_monster_index; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.start_monster_index = from.start_monster_index; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("start_monster_index") << _T(":") << start_monster_index;
					return ss.str();
				}
			} in;

			struct out_t {
				std::uint32_t result; // int

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, result, "result")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("result") << _T(":") << result;
					return ss.str();
				}
			} out;

			struct result_set_t {
				std::uint32_t monster_index; // int
				corn::TFixedStringA<50> monster_code; // varchar
				corn::TFixedStringA<50> monster_name; // varchar
				corn::TFixedStringA<50> reward_code; // varchar
				std::uint32_t monster_grade; // int
				std::uint32_t monster_gold_min; // int
				std::uint32_t monster_gold_max; // int
				std::uint32_t monster_exp; // int
				std::uint32_t Monster_Lv; // int
				corn::TFixedStringA<50> Attack_Type; // varchar
				std::uint32_t Item_MinDam; // int
				std::uint32_t Item_MaxDam; // int
				std::uint32_t Item_Att; // int
				std::uint32_t Item_Def; // int
				std::uint32_t Item_Health; // int
				float Dam_Slash; // float
				float Dam_Crash; // float
				float Dam_Pierce; // float
				std::uint32_t Item_Pen; // int
				float Item_PenPer; // float
				float Item_CriPer; // float
				float Item_CriRat; // float
				std::uint32_t Item_TrueDam; // int
				corn::TFixedStringA<50> TagRule; // varchar

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, monster_index, "monster_index")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, monster_code, "monster_code")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, monster_name, "monster_name")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, reward_code, "reward_code")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, monster_grade, "monster_grade")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, monster_gold_min, "monster_gold_min")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, monster_gold_max, "monster_gold_max")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, monster_exp, "monster_exp")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Monster_Lv, "Monster_Lv")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Attack_Type, "Attack_Type")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Item_MinDam, "Item_MinDam")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Item_MaxDam, "Item_MaxDam")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Item_Att, "Item_Att")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Item_Def, "Item_Def")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Item_Health, "Item_Health")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Dam_Slash, "Dam_Slash")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Dam_Crash, "Dam_Crash")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Dam_Pierce, "Dam_Pierce")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Item_Pen, "Item_Pen")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Item_PenPer, "Item_PenPer")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Item_CriPer, "Item_CriPer")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Item_CriRat, "Item_CriRat")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, Item_TrueDam, "Item_TrueDam")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, TagRule, "TagRule")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.monster_index = from.monster_index; // CT_PRIMITIVE
					to.monster_code = from.monster_code; // CT_STRING
					to.monster_name = from.monster_name; // CT_STRING
					to.reward_code = from.reward_code; // CT_STRING
					to.monster_grade = from.monster_grade; // CT_PRIMITIVE
					to.monster_gold_min = from.monster_gold_min; // CT_PRIMITIVE
					to.monster_gold_max = from.monster_gold_max; // CT_PRIMITIVE
					to.monster_exp = from.monster_exp; // CT_PRIMITIVE
					to.Monster_Lv = from.Monster_Lv; // CT_PRIMITIVE
					to.Attack_Type = from.Attack_Type; // CT_STRING
					to.Item_MinDam = from.Item_MinDam; // CT_PRIMITIVE
					to.Item_MaxDam = from.Item_MaxDam; // CT_PRIMITIVE
					to.Item_Att = from.Item_Att; // CT_PRIMITIVE
					to.Item_Def = from.Item_Def; // CT_PRIMITIVE
					to.Item_Health = from.Item_Health; // CT_PRIMITIVE
					to.Dam_Slash = from.Dam_Slash; // CT_PRIMITIVE
					to.Dam_Crash = from.Dam_Crash; // CT_PRIMITIVE
					to.Dam_Pierce = from.Dam_Pierce; // CT_PRIMITIVE
					to.Item_Pen = from.Item_Pen; // CT_PRIMITIVE
					to.Item_PenPer = from.Item_PenPer; // CT_PRIMITIVE
					to.Item_CriPer = from.Item_CriPer; // CT_PRIMITIVE
					to.Item_CriRat = from.Item_CriRat; // CT_PRIMITIVE
					to.Item_TrueDam = from.Item_TrueDam; // CT_PRIMITIVE
					to.TagRule = from.TagRule; // CT_STRING
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.monster_index = from.monster_index; // CT_PRIMITIVE
					to.monster_code = from.monster_code.c_str(); // CT_STRING
					to.monster_name = from.monster_name.c_str(); // CT_STRING
					to.reward_code = from.reward_code.c_str(); // CT_STRING
					to.monster_grade = from.monster_grade; // CT_PRIMITIVE
					to.monster_gold_min = from.monster_gold_min; // CT_PRIMITIVE
					to.monster_gold_max = from.monster_gold_max; // CT_PRIMITIVE
					to.monster_exp = from.monster_exp; // CT_PRIMITIVE
					to.Monster_Lv = from.Monster_Lv; // CT_PRIMITIVE
					to.Attack_Type = from.Attack_Type.c_str(); // CT_STRING
					to.Item_MinDam = from.Item_MinDam; // CT_PRIMITIVE
					to.Item_MaxDam = from.Item_MaxDam; // CT_PRIMITIVE
					to.Item_Att = from.Item_Att; // CT_PRIMITIVE
					to.Item_Def = from.Item_Def; // CT_PRIMITIVE
					to.Item_Health = from.Item_Health; // CT_PRIMITIVE
					to.Dam_Slash = from.Dam_Slash; // CT_PRIMITIVE
					to.Dam_Crash = from.Dam_Crash; // CT_PRIMITIVE
					to.Dam_Pierce = from.Dam_Pierce; // CT_PRIMITIVE
					to.Item_Pen = from.Item_Pen; // CT_PRIMITIVE
					to.Item_PenPer = from.Item_PenPer; // CT_PRIMITIVE
					to.Item_CriPer = from.Item_CriPer; // CT_PRIMITIVE
					to.Item_CriRat = from.Item_CriRat; // CT_PRIMITIVE
					to.Item_TrueDam = from.Item_TrueDam; // CT_PRIMITIVE
					to.TagRule = from.TagRule.c_str(); // CT_STRING
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.monster_index = from.monster_index; // CT_PRIMITIVE
					to.monster_code = from.monster_code.c_str(); // CT_STRING
					to.monster_name = from.monster_name.c_str(); // CT_STRING
					to.reward_code = from.reward_code.c_str(); // CT_STRING
					to.monster_grade = from.monster_grade; // CT_PRIMITIVE
					to.monster_gold_min = from.monster_gold_min; // CT_PRIMITIVE
					to.monster_gold_max = from.monster_gold_max; // CT_PRIMITIVE
					to.monster_exp = from.monster_exp; // CT_PRIMITIVE
					to.Monster_Lv = from.Monster_Lv; // CT_PRIMITIVE
					to.Attack_Type = from.Attack_Type.c_str(); // CT_STRING
					to.Item_MinDam = from.Item_MinDam; // CT_PRIMITIVE
					to.Item_MaxDam = from.Item_MaxDam; // CT_PRIMITIVE
					to.Item_Att = from.Item_Att; // CT_PRIMITIVE
					to.Item_Def = from.Item_Def; // CT_PRIMITIVE
					to.Item_Health = from.Item_Health; // CT_PRIMITIVE
					to.Dam_Slash = from.Dam_Slash; // CT_PRIMITIVE
					to.Dam_Crash = from.Dam_Crash; // CT_PRIMITIVE
					to.Dam_Pierce = from.Dam_Pierce; // CT_PRIMITIVE
					to.Item_Pen = from.Item_Pen; // CT_PRIMITIVE
					to.Item_PenPer = from.Item_PenPer; // CT_PRIMITIVE
					to.Item_CriPer = from.Item_CriPer; // CT_PRIMITIVE
					to.Item_CriRat = from.Item_CriRat; // CT_PRIMITIVE
					to.Item_TrueDam = from.Item_TrueDam; // CT_PRIMITIVE
					to.TagRule = from.TagRule.c_str(); // CT_STRING
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("monster_index") << _T(":") << monster_index;
					ss << _T(" in.") << _T("monster_code") << _T(":") << monster_code.c_str();
					ss << _T(" in.") << _T("monster_name") << _T(":") << monster_name.c_str();
					ss << _T(" in.") << _T("reward_code") << _T(":") << reward_code.c_str();
					ss << _T(" in.") << _T("monster_grade") << _T(":") << monster_grade;
					ss << _T(" in.") << _T("monster_gold_min") << _T(":") << monster_gold_min;
					ss << _T(" in.") << _T("monster_gold_max") << _T(":") << monster_gold_max;
					ss << _T(" in.") << _T("monster_exp") << _T(":") << monster_exp;
					ss << _T(" in.") << _T("Monster_Lv") << _T(":") << Monster_Lv;
					ss << _T(" in.") << _T("Attack_Type") << _T(":") << Attack_Type.c_str();
					ss << _T(" in.") << _T("Item_MinDam") << _T(":") << Item_MinDam;
					ss << _T(" in.") << _T("Item_MaxDam") << _T(":") << Item_MaxDam;
					ss << _T(" in.") << _T("Item_Att") << _T(":") << Item_Att;
					ss << _T(" in.") << _T("Item_Def") << _T(":") << Item_Def;
					ss << _T(" in.") << _T("Item_Health") << _T(":") << Item_Health;
					ss << _T(" in.") << _T("Dam_Slash") << _T(":") << Dam_Slash;
					ss << _T(" in.") << _T("Dam_Crash") << _T(":") << Dam_Crash;
					ss << _T(" in.") << _T("Dam_Pierce") << _T(":") << Dam_Pierce;
					ss << _T(" in.") << _T("Item_Pen") << _T(":") << Item_Pen;
					ss << _T(" in.") << _T("Item_PenPer") << _T(":") << Item_PenPer;
					ss << _T(" in.") << _T("Item_CriPer") << _T(":") << Item_CriPer;
					ss << _T(" in.") << _T("Item_CriRat") << _T(":") << Item_CriRat;
					ss << _T(" in.") << _T("Item_TrueDam") << _T(":") << Item_TrueDam;
					ss << _T(" in.") << _T("TagRule") << _T(":") << TagRule.c_str();
					return ss.str();
				}
			};

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.start_monster_index, "start_monster_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.result, "result")
			END_OTLA_BINDING
		}; // struct sp {

		//
		oTLA::StoredProcedure<sp_t> sp;
		oTLA::Search<sp_t::out_t> out;
		oTLA::Search<sp_t::result_set_t> result;
		oTLA::Search<sp_t::result_set_t> result_end;

		struct result_iterator {
			oTLA::Search<sp_t::result_set_t>* s_;
			result_iterator(oTLA::Search<sp_t::result_set_t>* s) : s_(s) {}			
			oTLA::Search<sp_t::result_set_t>::reference operator*() const { return *(*s_); }
			oTLA::Search<sp_t::result_set_t>::pointer operator->() const { return (*s_).operator->(); }
			bool operator!= (const result_iterator & rhs) const { return (*s_) != (*rhs.s_); }
			result_iterator& operator++() { ++(*s_); return *this; }
		};
		result_iterator begin() {
			return result_iterator(&result);
		}
		result_iterator end() {
			return result_iterator(&result_end);
		}
		int size() const {
			return result.Get_Row_Processed_Count();
		}
		
		template < typename UPDATER >
		void open( UPDATER* u, const TCHAR* db_name = nullptr )
		{
			result.SetExternalResultStream(sp.Get_Result_Stream());
			sp.Open(u, sp_name(db_name).c_str(), result);
			out.Open(u,nullptr);
		}
		template < typename T_start_monster_index >
		explicit sp_import_monster( char _dummy, const T_start_monster_index& start_monster_index ) {
			sp->in.start_monster_index = start_monster_index; // DEFAULT
		}
		template < typename T_start_monster_index >
		void init( const T_start_monster_index& start_monster_index ) {
			sp->in.start_monster_index = start_monster_index; // DEFAULT
		}
		template < typename PacketType >
		explicit sp_import_monster( const PacketType* p ) {
			init( 
				p->start_monster_index
			);
		}
	private:
		sp_import_monster() = delete;
	};
	/****************************************************************************
	*
	*	stored procedure: sp_import_mission
	*/
	struct sp_import_mission
	{
		static const char* name_A() { return "sp_import_mission"; }
		static const wchar_t* name_W() { return L"sp_import_mission"; };
		static const TCHAR* name() { return _T("sp_import_mission"); };

		static std::basic_string<TCHAR> sp_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_system"), name()).AsString();
		}

		struct sp_t {
			struct {
				std::uint32_t start_mission_index; // int

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.start_mission_index = from.start_mission_index; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.start_mission_index = from.start_mission_index; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.start_mission_index = from.start_mission_index; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("start_mission_index") << _T(":") << start_mission_index;
					return ss.str();
				}
			} in;

			struct out_t {
				std::uint32_t result; // int

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, result, "result")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("result") << _T(":") << result;
					return ss.str();
				}
			} out;

			struct result_set_t {
				std::uint32_t mission_index; // int
				corn::TFixedStringA<50> mission_code; // varchar
				corn::TFixedStringA<50> mission_name; // varchar
				std::uint32_t ap_cost; // int
				std::uint32_t mission_group; // int
				corn::TFixedStringA<50> boss_monster_code; // varchar
				std::uint32_t opt_monster_count; // int
				static const auto opt_monster_code__max_size = 10;
				corn::TFixedStringA<50> opt_monster_code[10]; // varchar
				corn::TFixedStringA<50> reward_code_if_cleard_1st; // varchar
				static const auto drop_item_index__max_size = 5;
				std::uint32_t drop_item_index[5]; // int

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, mission_index, "mission_index")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, mission_code, "mission_code")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, mission_name, "mission_name")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, ap_cost, "ap_cost")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, mission_group, "mission_group")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, boss_monster_code, "boss_monster_code")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, opt_monster_count, "opt_monster_count")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, opt_monster_code[0], "opt_monster_code_0")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, opt_monster_code[1], "opt_monster_code_1")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, opt_monster_code[2], "opt_monster_code_2")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, opt_monster_code[3], "opt_monster_code_3")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, opt_monster_code[4], "opt_monster_code_4")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, opt_monster_code[5], "opt_monster_code_5")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, opt_monster_code[6], "opt_monster_code_6")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, opt_monster_code[7], "opt_monster_code_7")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, opt_monster_code[8], "opt_monster_code_8")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, opt_monster_code[9], "opt_monster_code_9")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, reward_code_if_cleard_1st, "reward_code_if_cleard_1st")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, drop_item_index[0], "drop_item_index_0")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, drop_item_index[1], "drop_item_index_1")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, drop_item_index[2], "drop_item_index_2")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, drop_item_index[3], "drop_item_index_3")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, drop_item_index[4], "drop_item_index_4")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.mission_index = from.mission_index; // CT_PRIMITIVE
					to.mission_code = from.mission_code; // CT_STRING
					to.mission_name = from.mission_name; // CT_STRING
					to.ap_cost = from.ap_cost; // CT_PRIMITIVE
					to.mission_group = from.mission_group; // CT_PRIMITIVE
					to.boss_monster_code = from.boss_monster_code; // CT_STRING
					to.opt_monster_count = from.opt_monster_count; // CT_PRIMITIVE
					for ( int i = 0; i < 10; ++i )
						to.opt_monster_code[i] = from.opt_monster_code[i]; // CT_STRING[]
					to.reward_code_if_cleard_1st = from.reward_code_if_cleard_1st; // CT_STRING
					for ( int i = 0; i < 5; ++i )
						to.drop_item_index[i] = from.drop_item_index[i]; // CT_PRIMITIVE[]
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.mission_index = from.mission_index; // CT_PRIMITIVE
					to.mission_code = from.mission_code.c_str(); // CT_STRING
					to.mission_name = from.mission_name.c_str(); // CT_STRING
					to.ap_cost = from.ap_cost; // CT_PRIMITIVE
					to.mission_group = from.mission_group; // CT_PRIMITIVE
					to.boss_monster_code = from.boss_monster_code.c_str(); // CT_STRING
					to.opt_monster_count = from.opt_monster_count; // CT_PRIMITIVE
					for ( int i = 0; i < 10; ++i )
						to.opt_monster_code[i] = from.opt_monster_code[i].c_str(); // CT_STRING[]
					to.reward_code_if_cleard_1st = from.reward_code_if_cleard_1st.c_str(); // CT_STRING
					for ( int i = 0; i < 5; ++i )
						to.drop_item_index[i] = from.drop_item_index[i]; // CT_PRIMITIVE[]
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.mission_index = from.mission_index; // CT_PRIMITIVE
					to.mission_code = from.mission_code.c_str(); // CT_STRING
					to.mission_name = from.mission_name.c_str(); // CT_STRING
					to.ap_cost = from.ap_cost; // CT_PRIMITIVE
					to.mission_group = from.mission_group; // CT_PRIMITIVE
					to.boss_monster_code = from.boss_monster_code.c_str(); // CT_STRING
					to.opt_monster_count = from.opt_monster_count; // CT_PRIMITIVE
					for ( int i = 0; i < 10; ++i )
						to.opt_monster_code[i] = from.opt_monster_code[i].c_str(); // CT_STRING[]
					to.reward_code_if_cleard_1st = from.reward_code_if_cleard_1st.c_str(); // CT_STRING
					for ( int i = 0; i < 5; ++i )
						to.drop_item_index[i] = from.drop_item_index[i]; // CT_PRIMITIVE[]
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("mission_index") << _T(":") << mission_index;
					ss << _T(" in.") << _T("mission_code") << _T(":") << mission_code.c_str();
					ss << _T(" in.") << _T("mission_name") << _T(":") << mission_name.c_str();
					ss << _T(" in.") << _T("ap_cost") << _T(":") << ap_cost;
					ss << _T(" in.") << _T("mission_group") << _T(":") << mission_group;
					ss << _T(" in.") << _T("boss_monster_code") << _T(":") << boss_monster_code.c_str();
					ss << _T(" in.") << _T("opt_monster_count") << _T(":") << opt_monster_count;
					ss << _T(" in.") << _T("opt_monster_code[0]") << _T(":") << opt_monster_code[0].c_str();
					ss << _T(" in.") << _T("opt_monster_code[1]") << _T(":") << opt_monster_code[1].c_str();
					ss << _T(" in.") << _T("opt_monster_code[2]") << _T(":") << opt_monster_code[2].c_str();
					ss << _T(" in.") << _T("opt_monster_code[3]") << _T(":") << opt_monster_code[3].c_str();
					ss << _T(" in.") << _T("opt_monster_code[4]") << _T(":") << opt_monster_code[4].c_str();
					ss << _T(" in.") << _T("opt_monster_code[5]") << _T(":") << opt_monster_code[5].c_str();
					ss << _T(" in.") << _T("opt_monster_code[6]") << _T(":") << opt_monster_code[6].c_str();
					ss << _T(" in.") << _T("opt_monster_code[7]") << _T(":") << opt_monster_code[7].c_str();
					ss << _T(" in.") << _T("opt_monster_code[8]") << _T(":") << opt_monster_code[8].c_str();
					ss << _T(" in.") << _T("opt_monster_code[9]") << _T(":") << opt_monster_code[9].c_str();
					ss << _T(" in.") << _T("reward_code_if_cleard_1st") << _T(":") << reward_code_if_cleard_1st.c_str();
					ss << _T(" in.") << _T("drop_item_index[0]") << _T(":") << drop_item_index[0];
					ss << _T(" in.") << _T("drop_item_index[1]") << _T(":") << drop_item_index[1];
					ss << _T(" in.") << _T("drop_item_index[2]") << _T(":") << drop_item_index[2];
					ss << _T(" in.") << _T("drop_item_index[3]") << _T(":") << drop_item_index[3];
					ss << _T(" in.") << _T("drop_item_index[4]") << _T(":") << drop_item_index[4];
					return ss.str();
				}
			};

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.start_mission_index, "start_mission_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.result, "result")
			END_OTLA_BINDING
		}; // struct sp {

		//
		oTLA::StoredProcedure<sp_t> sp;
		oTLA::Search<sp_t::out_t> out;
		oTLA::Search<sp_t::result_set_t> result;
		oTLA::Search<sp_t::result_set_t> result_end;

		struct result_iterator {
			oTLA::Search<sp_t::result_set_t>* s_;
			result_iterator(oTLA::Search<sp_t::result_set_t>* s) : s_(s) {}			
			oTLA::Search<sp_t::result_set_t>::reference operator*() const { return *(*s_); }
			oTLA::Search<sp_t::result_set_t>::pointer operator->() const { return (*s_).operator->(); }
			bool operator!= (const result_iterator & rhs) const { return (*s_) != (*rhs.s_); }
			result_iterator& operator++() { ++(*s_); return *this; }
		};
		result_iterator begin() {
			return result_iterator(&result);
		}
		result_iterator end() {
			return result_iterator(&result_end);
		}
		int size() const {
			return result.Get_Row_Processed_Count();
		}
		
		template < typename UPDATER >
		void open( UPDATER* u, const TCHAR* db_name = nullptr )
		{
			result.SetExternalResultStream(sp.Get_Result_Stream());
			sp.Open(u, sp_name(db_name).c_str(), result);
			out.Open(u,nullptr);
		}
		template < typename T_start_mission_index >
		explicit sp_import_mission( char _dummy, const T_start_mission_index& start_mission_index ) {
			sp->in.start_mission_index = start_mission_index; // DEFAULT
		}
		template < typename T_start_mission_index >
		void init( const T_start_mission_index& start_mission_index ) {
			sp->in.start_mission_index = start_mission_index; // DEFAULT
		}
		template < typename PacketType >
		explicit sp_import_mission( const PacketType* p ) {
			init( 
				p->start_mission_index
			);
		}
	private:
		sp_import_mission() = delete;
	};
	/****************************************************************************
	*
	*	stored procedure: sp_import_item
	*/
	struct sp_import_item
	{
		static const char* name_A() { return "sp_import_item"; }
		static const wchar_t* name_W() { return L"sp_import_item"; };
		static const TCHAR* name() { return _T("sp_import_item"); };

		static std::basic_string<TCHAR> sp_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_system"), name()).AsString();
		}

		struct sp_t {
			struct {
				std::uint32_t start_item_index; // int

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.start_item_index = from.start_item_index; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.start_item_index = from.start_item_index; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.start_item_index = from.start_item_index; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("start_item_index") << _T(":") << start_item_index;
					return ss.str();
				}
			} in;

			struct out_t {
				std::uint32_t result; // int

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, result, "result")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("result") << _T(":") << result;
					return ss.str();
				}
			} out;

			struct result_set_t {
				std::uint32_t item_index; // int
				corn::TFixedStringA<50> code; // varchar
				corn::TFixedStringA<50> name; // varchar
				std::uint32_t item_tier; // int
				std::uint32_t grade; // int
				std::uint32_t max_stack; // int
				std::uint32_t max_level; // int
				corn::TFixedStringA<50> item_desc; // varchar
				std::uint32_t slot; // int
				std::uint32_t evolvable_item_index; // int
				std::uint32_t equippable_char_index; // int
				std::uint32_t base_sell_price; // int
				corn::TFixedStringA<50> reward_code_on_use; // varchar
				std::uint32_t expire_in_hours; // int

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, item_index, "item_index")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, code, "code")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, name, "name")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, item_tier, "item_tier")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, grade, "grade")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, max_stack, "max_stack")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, max_level, "max_level")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, item_desc, "item_desc")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, slot, "slot")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, evolvable_item_index, "evolvable_item_index")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, equippable_char_index, "equippable_char_index")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, base_sell_price, "base_sell_price")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, reward_code_on_use, "reward_code_on_use")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expire_in_hours, "expire_in_hours")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.item_index = from.item_index; // CT_PRIMITIVE
					to.code = from.code; // CT_STRING
					to.name = from.name; // CT_STRING
					to.item_tier = from.item_tier; // CT_PRIMITIVE
					to.grade = from.grade; // CT_PRIMITIVE
					to.max_stack = from.max_stack; // CT_PRIMITIVE
					to.max_level = from.max_level; // CT_PRIMITIVE
					to.item_desc = from.item_desc; // CT_STRING
					to.slot = from.slot; // CT_PRIMITIVE
					to.evolvable_item_index = from.evolvable_item_index; // CT_PRIMITIVE
					to.equippable_char_index = from.equippable_char_index; // CT_PRIMITIVE
					to.base_sell_price = from.base_sell_price; // CT_PRIMITIVE
					to.reward_code_on_use = from.reward_code_on_use; // CT_STRING
					to.expire_in_hours = from.expire_in_hours; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.item_index = from.item_index; // CT_PRIMITIVE
					to.code = from.code.c_str(); // CT_STRING
					to.name = from.name.c_str(); // CT_STRING
					to.item_tier = from.item_tier; // CT_PRIMITIVE
					to.grade = from.grade; // CT_PRIMITIVE
					to.max_stack = from.max_stack; // CT_PRIMITIVE
					to.max_level = from.max_level; // CT_PRIMITIVE
					to.item_desc = from.item_desc.c_str(); // CT_STRING
					to.slot = from.slot; // CT_PRIMITIVE
					to.evolvable_item_index = from.evolvable_item_index; // CT_PRIMITIVE
					to.equippable_char_index = from.equippable_char_index; // CT_PRIMITIVE
					to.base_sell_price = from.base_sell_price; // CT_PRIMITIVE
					to.reward_code_on_use = from.reward_code_on_use.c_str(); // CT_STRING
					to.expire_in_hours = from.expire_in_hours; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.item_index = from.item_index; // CT_PRIMITIVE
					to.code = from.code.c_str(); // CT_STRING
					to.name = from.name.c_str(); // CT_STRING
					to.item_tier = from.item_tier; // CT_PRIMITIVE
					to.grade = from.grade; // CT_PRIMITIVE
					to.max_stack = from.max_stack; // CT_PRIMITIVE
					to.max_level = from.max_level; // CT_PRIMITIVE
					to.item_desc = from.item_desc.c_str(); // CT_STRING
					to.slot = from.slot; // CT_PRIMITIVE
					to.evolvable_item_index = from.evolvable_item_index; // CT_PRIMITIVE
					to.equippable_char_index = from.equippable_char_index; // CT_PRIMITIVE
					to.base_sell_price = from.base_sell_price; // CT_PRIMITIVE
					to.reward_code_on_use = from.reward_code_on_use.c_str(); // CT_STRING
					to.expire_in_hours = from.expire_in_hours; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("item_index") << _T(":") << item_index;
					ss << _T(" in.") << _T("code") << _T(":") << code.c_str();
					ss << _T(" in.") << _T("name") << _T(":") << name.c_str();
					ss << _T(" in.") << _T("item_tier") << _T(":") << item_tier;
					ss << _T(" in.") << _T("grade") << _T(":") << grade;
					ss << _T(" in.") << _T("max_stack") << _T(":") << max_stack;
					ss << _T(" in.") << _T("max_level") << _T(":") << max_level;
					ss << _T(" in.") << _T("item_desc") << _T(":") << item_desc.c_str();
					ss << _T(" in.") << _T("slot") << _T(":") << slot;
					ss << _T(" in.") << _T("evolvable_item_index") << _T(":") << evolvable_item_index;
					ss << _T(" in.") << _T("equippable_char_index") << _T(":") << equippable_char_index;
					ss << _T(" in.") << _T("base_sell_price") << _T(":") << base_sell_price;
					ss << _T(" in.") << _T("reward_code_on_use") << _T(":") << reward_code_on_use.c_str();
					ss << _T(" in.") << _T("expire_in_hours") << _T(":") << expire_in_hours;
					return ss.str();
				}
			};

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.start_item_index, "start_item_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.result, "result")
			END_OTLA_BINDING
		}; // struct sp {

		//
		oTLA::StoredProcedure<sp_t> sp;
		oTLA::Search<sp_t::out_t> out;
		oTLA::Search<sp_t::result_set_t> result;
		oTLA::Search<sp_t::result_set_t> result_end;

		struct result_iterator {
			oTLA::Search<sp_t::result_set_t>* s_;
			result_iterator(oTLA::Search<sp_t::result_set_t>* s) : s_(s) {}			
			oTLA::Search<sp_t::result_set_t>::reference operator*() const { return *(*s_); }
			oTLA::Search<sp_t::result_set_t>::pointer operator->() const { return (*s_).operator->(); }
			bool operator!= (const result_iterator & rhs) const { return (*s_) != (*rhs.s_); }
			result_iterator& operator++() { ++(*s_); return *this; }
		};
		result_iterator begin() {
			return result_iterator(&result);
		}
		result_iterator end() {
			return result_iterator(&result_end);
		}
		int size() const {
			return result.Get_Row_Processed_Count();
		}
		
		template < typename UPDATER >
		void open( UPDATER* u, const TCHAR* db_name = nullptr )
		{
			result.SetExternalResultStream(sp.Get_Result_Stream());
			sp.Open(u, sp_name(db_name).c_str(), result);
			out.Open(u,nullptr);
		}
		template < typename T_start_item_index >
		explicit sp_import_item( char _dummy, const T_start_item_index& start_item_index ) {
			sp->in.start_item_index = start_item_index; // DEFAULT
		}
		template < typename T_start_item_index >
		void init( const T_start_item_index& start_item_index ) {
			sp->in.start_item_index = start_item_index; // DEFAULT
		}
		template < typename PacketType >
		explicit sp_import_item( const PacketType* p ) {
			init( 
				p->start_item_index
			);
		}
	private:
		sp_import_item() = delete;
	};
	/****************************************************************************
	*
	*	stored procedure: sp_import_reward
	*/
	struct sp_import_reward
	{
		static const char* name_A() { return "sp_import_reward"; }
		static const wchar_t* name_W() { return L"sp_import_reward"; };
		static const TCHAR* name() { return _T("sp_import_reward"); };

		static std::basic_string<TCHAR> sp_name( const TCHAR* db_name = nullptr )
		{
			return FormatString(_T("%s.%s"), db_name ? db_name : _T("bb_system"), name()).AsString();
		}

		struct sp_t {
			struct {
				std::uint32_t start_reward_index; // int

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.start_reward_index = from.start_reward_index; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.start_reward_index = from.start_reward_index; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.start_reward_index = from.start_reward_index; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("start_reward_index") << _T(":") << start_reward_index;
					return ss.str();
				}
			} in;

			struct out_t {
				std::uint32_t result; // int

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_FROM_DB, result, "result")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.result = from.result; // CT_PRIMITIVE
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("result") << _T(":") << result;
					return ss.str();
				}
			} out;

			struct result_set_t {
				std::uint32_t reward_index; // int
				corn::TFixedStringA<50> reward_code; // varchar
				corn::TFixedStringA<50> expr_gold; // varchar
				corn::TFixedStringA<50> expr_ruby; // varchar
				corn::TFixedStringA<50> expr_honor; // varchar
				corn::TFixedStringA<50> expr_exp; // varchar
				corn::TFixedStringA<50> expr_ap; // varchar
				static const auto expr_item__max_size = 20;
				corn::TFixedStringA<50> expr_item[20]; // varchar

				BEGIN_OTLA_BINDING
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, reward_index, "reward_index")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, reward_code, "reward_code")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_gold, "expr_gold")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_ruby, "expr_ruby")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_honor, "expr_honor")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_exp, "expr_exp")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_ap, "expr_ap")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[0], "expr_item_0")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[1], "expr_item_1")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[2], "expr_item_2")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[3], "expr_item_3")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[4], "expr_item_4")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[5], "expr_item_5")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[6], "expr_item_6")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[7], "expr_item_7")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[8], "expr_item_8")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[9], "expr_item_9")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[10], "expr_item_10")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[11], "expr_item_11")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[12], "expr_item_12")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[13], "expr_item_13")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[14], "expr_item_14")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[15], "expr_item_15")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[16], "expr_item_16")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[17], "expr_item_17")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[18], "expr_item_18")
					OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_ARG, expr_item[19], "expr_item_19")
				END_OTLA_BINDING

				template < typename U, typename V > // packet to packet
				static void copy(const U& from, V& to) {
					to.reward_index = from.reward_index; // CT_PRIMITIVE
					to.reward_code = from.reward_code; // CT_STRING
					to.expr_gold = from.expr_gold; // CT_STRING
					to.expr_ruby = from.expr_ruby; // CT_STRING
					to.expr_honor = from.expr_honor; // CT_STRING
					to.expr_exp = from.expr_exp; // CT_STRING
					to.expr_ap = from.expr_ap; // CT_STRING
					for ( int i = 0; i < 20; ++i )
						to.expr_item[i] = from.expr_item[i]; // CT_STRING[]
				}
				template < typename DB, typename T > // db to packet
				static void copy_from( const DB& from, T& to ) {
					to.reward_index = from.reward_index; // CT_PRIMITIVE
					to.reward_code = from.reward_code.c_str(); // CT_STRING
					to.expr_gold = from.expr_gold.c_str(); // CT_STRING
					to.expr_ruby = from.expr_ruby.c_str(); // CT_STRING
					to.expr_honor = from.expr_honor.c_str(); // CT_STRING
					to.expr_exp = from.expr_exp.c_str(); // CT_STRING
					to.expr_ap = from.expr_ap.c_str(); // CT_STRING
					for ( int i = 0; i < 20; ++i )
						to.expr_item[i] = from.expr_item[i].c_str(); // CT_STRING[]
				}
				template < typename DB, typename T > // packet to db
				static void copy_to( const T& from, DB& to ) {
					to.reward_index = from.reward_index; // CT_PRIMITIVE
					to.reward_code = from.reward_code.c_str(); // CT_STRING
					to.expr_gold = from.expr_gold.c_str(); // CT_STRING
					to.expr_ruby = from.expr_ruby.c_str(); // CT_STRING
					to.expr_honor = from.expr_honor.c_str(); // CT_STRING
					to.expr_exp = from.expr_exp.c_str(); // CT_STRING
					to.expr_ap = from.expr_ap.c_str(); // CT_STRING
					for ( int i = 0; i < 20; ++i )
						to.expr_item[i] = from.expr_item[i].c_str(); // CT_STRING[]
				}
				std::basic_string<TCHAR> as_string() const {
					std::basic_stringstream<TCHAR> ss;
					ss << _T(" in.") << _T("reward_index") << _T(":") << reward_index;
					ss << _T(" in.") << _T("reward_code") << _T(":") << reward_code.c_str();
					ss << _T(" in.") << _T("expr_gold") << _T(":") << expr_gold.c_str();
					ss << _T(" in.") << _T("expr_ruby") << _T(":") << expr_ruby.c_str();
					ss << _T(" in.") << _T("expr_honor") << _T(":") << expr_honor.c_str();
					ss << _T(" in.") << _T("expr_exp") << _T(":") << expr_exp.c_str();
					ss << _T(" in.") << _T("expr_ap") << _T(":") << expr_ap.c_str();
					ss << _T(" in.") << _T("expr_item[0]") << _T(":") << expr_item[0].c_str();
					ss << _T(" in.") << _T("expr_item[1]") << _T(":") << expr_item[1].c_str();
					ss << _T(" in.") << _T("expr_item[2]") << _T(":") << expr_item[2].c_str();
					ss << _T(" in.") << _T("expr_item[3]") << _T(":") << expr_item[3].c_str();
					ss << _T(" in.") << _T("expr_item[4]") << _T(":") << expr_item[4].c_str();
					ss << _T(" in.") << _T("expr_item[5]") << _T(":") << expr_item[5].c_str();
					ss << _T(" in.") << _T("expr_item[6]") << _T(":") << expr_item[6].c_str();
					ss << _T(" in.") << _T("expr_item[7]") << _T(":") << expr_item[7].c_str();
					ss << _T(" in.") << _T("expr_item[8]") << _T(":") << expr_item[8].c_str();
					ss << _T(" in.") << _T("expr_item[9]") << _T(":") << expr_item[9].c_str();
					ss << _T(" in.") << _T("expr_item[10]") << _T(":") << expr_item[10].c_str();
					ss << _T(" in.") << _T("expr_item[11]") << _T(":") << expr_item[11].c_str();
					ss << _T(" in.") << _T("expr_item[12]") << _T(":") << expr_item[12].c_str();
					ss << _T(" in.") << _T("expr_item[13]") << _T(":") << expr_item[13].c_str();
					ss << _T(" in.") << _T("expr_item[14]") << _T(":") << expr_item[14].c_str();
					ss << _T(" in.") << _T("expr_item[15]") << _T(":") << expr_item[15].c_str();
					ss << _T(" in.") << _T("expr_item[16]") << _T(":") << expr_item[16].c_str();
					ss << _T(" in.") << _T("expr_item[17]") << _T(":") << expr_item[17].c_str();
					ss << _T(" in.") << _T("expr_item[18]") << _T(":") << expr_item[18].c_str();
					ss << _T(" in.") << _T("expr_item[19]") << _T(":") << expr_item[19].c_str();
					return ss.str();
				}
			};

			BEGIN_OTLA_BINDING
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_IN_ARG, in.start_reward_index, "start_reward_index")
				OTLA_BIND_ATT_COLUMN_NAME(oTLA::SP_OUT_SET_ARG, out.result, "result")
			END_OTLA_BINDING
		}; // struct sp {

		//
		oTLA::StoredProcedure<sp_t> sp;
		oTLA::Search<sp_t::out_t> out;
		oTLA::Search<sp_t::result_set_t> result;
		oTLA::Search<sp_t::result_set_t> result_end;

		struct result_iterator {
			oTLA::Search<sp_t::result_set_t>* s_;
			result_iterator(oTLA::Search<sp_t::result_set_t>* s) : s_(s) {}			
			oTLA::Search<sp_t::result_set_t>::reference operator*() const { return *(*s_); }
			oTLA::Search<sp_t::result_set_t>::pointer operator->() const { return (*s_).operator->(); }
			bool operator!= (const result_iterator & rhs) const { return (*s_) != (*rhs.s_); }
			result_iterator& operator++() { ++(*s_); return *this; }
		};
		result_iterator begin() {
			return result_iterator(&result);
		}
		result_iterator end() {
			return result_iterator(&result_end);
		}
		int size() const {
			return result.Get_Row_Processed_Count();
		}
		
		template < typename UPDATER >
		void open( UPDATER* u, const TCHAR* db_name = nullptr )
		{
			result.SetExternalResultStream(sp.Get_Result_Stream());
			sp.Open(u, sp_name(db_name).c_str(), result);
			out.Open(u,nullptr);
		}
		template < typename T_start_reward_index >
		explicit sp_import_reward( char _dummy, const T_start_reward_index& start_reward_index ) {
			sp->in.start_reward_index = start_reward_index; // DEFAULT
		}
		template < typename T_start_reward_index >
		void init( const T_start_reward_index& start_reward_index ) {
			sp->in.start_reward_index = start_reward_index; // DEFAULT
		}
		template < typename PacketType >
		explicit sp_import_reward( const PacketType* p ) {
			init( 
				p->start_reward_index
			);
		}
	private:
		sp_import_reward() = delete;
	};

} // namespace
#pragma warning(pop)
